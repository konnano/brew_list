#!/usr/bin/env perl
use strict;
use warnings;
use Encode;
use NDBM_File;
use Fcntl ':DEFAULT';
my( $OS_Version,$Locale,%JA );
chomp(my $MY_BREW = `dirname \$(dirname \$(which brew 2>/dev/null) 2>/dev/null) 2>/dev/null`);

MAIN:{
 my $HOME = "$ENV{'HOME'}/.BREW_LIST";
 my $re  = { 'LEN1'=>1,'FOR'=>1,'ARR'=>[],'IN'=>0,'UP'=>0,'ARY'=>[],'UNI'=>[],
             'CEL'=>'/usr/local/Cellar','BIN'=>'/usr/local/opt',
             'HOME'=>$HOME,'TXT'=>"$HOME/brew.txt",
             'TAP_S'=>'/usr/local/Homebrew/Library/Taps',
             'CAN'=>"$HOME/ana.txt",'SPA'=>' 'x9 };

 my $ref = { 'LEN1'=>1,'CAS'=>1,'ARR'=>[],'IN'=>0,'UP'=>0,'ARY'=>[],
             'CEL'=>'/usr/local/Caskroom','LEN2'=>1,'LEN3'=>1,'LEN4'=>1,
             'HOME'=>$HOME,'TXT'=>"$HOME/cask.txt",'CAN'=>"$HOME/cna.txt",
             'Q_TAP'=>"$HOME/Q_TAP.txt",'SPA'=>' 'x9 };

 $^O eq 'darwin' ? $re->{'MAC'} = $ref->{'MAC'}= 1 :
  $^O eq 'linux' ? $re->{'LIN'} = 1 : die " Not support OS\n";

 my @AR = @ARGV; my $name;
  Died_1() unless $AR[0];
 if( $AR[0] eq '-l' ){      $name = $re;  $re->{'LIST'}  = 1;
 }elsif( $AR[0] eq '-i'  ){ $name = $re;  $re->{'PRINT'} = 1;
 }elsif( $AR[0] eq '-c'  ){ $name = $ref; $ref->{'LIST'} = 1; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-ci' ){ $name = $ref; $ref->{'PRINT'}= 1; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-cd' ){ $name = $ref; $ref->{'DEP'}  = 1; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-ct' ){ $name = $ref; $ref->{'LIST'} = $ref->{'TAP'} = 1; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-ctp'){ $name = $ref; $ref->{'LIST'} = $ref->{'TAP'} = $ref->{'LINK'} = 8;
                            Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-p'  ){ $name = $ref;  $ref->{'PRE'} = $ref->{'TAP'} = 1; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-lx' ){ $name = $re;  $re->{'LIST'}  = $re->{'LINK'} = $re->{'MAC'} ? 1 : 2;
 }elsif( $AR[0] eq '-lb' ){ $name = $re;  $re->{'LIST'}  = $re->{'LINK'} = 3;
 }elsif( $AR[0] eq '-cx' ){ $name = $ref; $ref->{'LIST'} = $ref->{'LINK'}= 4; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-cs' ){ $name = $ref; $ref->{'LIST'} = $ref->{'LINK'}= 5; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-in' ){ $re->{'LIST'} = $re->{'INF'} = $re->{'LINK'} =
                            $ref->{'LIST'}= $ref->{'INF'}= $ref->{'LINK'}= 6;
 }elsif( $AR[0] eq '-de' ){ $re->{'INF'}  = $re->{'LINK'}= $ref->{'INF'} = $ref->{'LINK'}= 7;
                            $ref->{'DEL'} = $re->{'DEL'} = 1;
 }elsif( $AR[0] eq '-t'  ){ $name = $re;  $re->{'INF'} = $re->{'TREE'}= 1;
 }elsif( $AR[0] eq '-tt' ){ $name = $re;  $re->{'INF'} = $re->{'TREE'}= $re->{'TT'}= 1;
 }elsif( $AR[0] eq '-d'  ){ $name = $re;  $re->{'INF'} = $re->{'DEL'} = $re->{'D'} = 1;
 }elsif( $AR[0] eq '-dd' ){ $name = $re;  $re->{'INF'} = $re->{'DEL'} = $re->{'D'} = $re->{'DD'} = 1;
 }elsif( $AR[0] eq '-ddd'){ $name = $re;  $re->{'INF'} = $re->{'DEL'} = $re->{'D'} = $re->{'DD'} = $re->{'DDD'} = 1;
 }elsif( $AR[0] eq '-ac' ){ $name = $ref; $ref->{'ANA'} = 1; Died_1() if $re->{'LIN'};
 }elsif( $AR[0] eq '-ai' ){ $name = $re;  $re->{'ANA'}  = 1;
 }elsif( $AR[0] eq '-u'  ){ $name = $re;  $re->{'USE'}  = 1;
 }elsif( $AR[0] eq '-ua' ){ $name = $re;  $re->{'USES'} = $re->{'USE'} = 1;
 }elsif( $AR[0] eq '-ul' ){ $name = $re;  $re->{'uses'} = 1;
 }elsif( $AR[0] eq '-ud' ){ $name = $re;  $re->{'deps'} = 1;
 }elsif( $AR[0] eq '-co' ){ $name = $re;  $re->{'COM'}  = 1;
 }elsif( $AR[0] eq '-new'){ $name = $re;  $re->{'NEW'}  = 1;
 }elsif( $AR[0] eq '-is' ){ $name = $re;  $re->{'IS'}   = 1;
 }elsif( $AR[0] eq '-o'  ){ $re->{'DAT'}= $ref->{'DAT'} = 1;
 }elsif( $AR[0] eq '-g'  ){ $re->{'TOP'}= $ref->{'TOP'} = 1;
 }elsif( $AR[0] eq  '-'  ){ $re->{'BL'} = $ref->{'BL'}  = 1;
 }elsif( $AR[0] eq '-s'  ){ $re->{'S_OPT'} = 1;
 }elsif( $AR[0] eq '-JA' ){ $re->{'JA'} = 1;
 }else{  Died_1();
 }
  my $UNAME = `uname -m` !~ /arm64|aarch64/ ? 'x86_64' : 'arm64';
 if( $re->{'LIN'} ){
  $re->{'CEL'} = "$MY_BREW/Cellar";
   $re->{'BIN'} = "$MY_BREW/opt";
    $MY_BREW = -d "$MY_BREW/Homebrew" ? $MY_BREW.'/Homebrew' : $MY_BREW;
    $re->{'TAP_S'} = "$MY_BREW/Library/Taps";
     $OS_Version = $UNAME =~ /x86_64/ ? 'Linux' : 'LinuxM1';
 }else{
  $OS_Version =  `sw_vers -productVersion`;
   $OS_Version =~ s/^(10\.1[0-5]).*\n/$1/;
    $OS_Version =~ s/^10\.9.*\n/10.09/;
     $OS_Version =~ s/^(1[1-3]).+\n/$1.0/;
  die " Use Tiger Brew\n" if $OS_Version =~ /^10\.[0-8]($|\.)/;
   $OS_Version = "${OS_Version}M1" if $UNAME =~ /arm64/;
  $ref->{'VERS'} = 1 if -d '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-versions';
   $ref->{'DDIR'} = 1 if -d '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-drivers';
    $ref->{'FDIR'} = 1 if -d '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-fonts';
 }

 if( $re->{'MAC'} and ( $UNAME =~ /arm64/ or not -d '/usr/local/Homebrew' ) ){
  $re->{'CEL'} = "$MY_BREW/Cellar";
   $re->{'BIN'} = "$MY_BREW/opt";
    $ref->{'CEL'} = "$MY_BREW/Caskroom";
     $re->{'TAP_S'} = "$MY_BREW/Library/Taps";
  $ref->{'VERS'} = 1 if -d "$MY_BREW/Library/Taps/homebrew/homebrew-cask-versions";
   $ref->{'DDIR'} = 1 if -d "$MY_BREW/Library/Taps/homebrew/homebrew-cask-drivers";
    $ref->{'FDIR'} = 1 if -d "$MY_BREW/Library/Taps/homebrew/homebrew-cask-fonts";
 }
   die " \033[31mNot installed HOME BREW\033[0m\n" unless -d $re->{'CEL'};
    my $Lc = `printf \$LC_ALL \$LC_CTYPE \$LANG 2>/dev/null`;
     $Locale = ( $Lc and $Lc =~ /ja_jp\.utf-?8$/i ) ? 2 : ( $Lc and $Lc =~ /utf-?8$/i ) ? 1 : 0;
  if( $re->{'JA'} ){
   die " \033[31mNot connected\033[0m\n"
    if system 'curl -k https://formulae.brew.sh/formula >/dev/null 2>&1';
   die " Not ja_JP.UTF-8 Locale\n" if $Locale < 2;
    -d "$ENV{'HOME'}/.JA_BREW" ?
     print" exists ~/.JA_BREW\n" : system 'git clone https://github.com/konnano/JA_BREW ~/.JA_BREW';
      $? ? die " can not git clone ~/.JA_BREW\n" : exit;
  }elsif( -d "$ENV{'HOME'}/.JA_BREW" and $AR[1] and $AR[1] eq 'EN' ){
   $name ? $name->{'EN'} = 1 : ( not $name ) ? $re->{'EN'} = $ref->{'EN'} = 1 : 0;
    $AR[1] = $AR[2] if defined $AR[2]; $AR[2] = $AR[3] || '';
  }elsif( not $Locale ){
   $name ? $name->{'EN'} = 1 : ( not $name ) ? $re->{'EN'} = $ref->{'EN'} = 1 : 0;
  }
  unless( not $ref->{'TAP'} or $ref->{'FDIR'} or $ref->{'DDIR'} or $ref->{'VERS'} ){
   print " not exists cask tap\n homebrew/cask-fonts\n homebrew/cask-drivers\n homebrew/cask-versions\n";
    File_1( $ref );
  }elsif( $ref->{'PRE'} and not $ref->{'FDIR'} ){
   print " not exists cask tap homebrew/cask-fonts\n";
    File_1( $ref );
  }

  if( $AR[1] and $AR[1] =~ m[/.*(\\Q|\\E).*/]i ){
   $AR[1] !~ /.*\\Q.+\\E.*/ ? die " nothing in regex\n" : $AR[1] =~ s|/(.*)\\Q(.+)\\E(.*)/|/$1\Q$2\E$3/|;
  }elsif( $AR[1] and my( $reg )= $AR[1] =~ m|^/(.+)/$| ){
   die " nothing in regex\n" if system "perl -e '$AR[1]=~/$reg/' 2>/dev/null";
  }
   if( $name and $AR[2] and $AR[2] eq '.' and not $re->{'deps'} and not $re->{'INF'}){ $name->{'KEN'} = 1;
   }elsif( $re->{'deps'} and $AR[1] and $AR[1] eq '.' ){ $name->{'KEN'} = 1;
   }elsif( $name and $re->{'INF'} and $AR[2] ){ $name->{'KEN'} = $AR[2];
   }
    $ref->{'BIN'} = $re->{'BIN'} if $ref->{'DEP'};
     $re->{'CELS'} = $ref->{'CEL'} if $re->{'MAC'} and
      ( $re->{'TOP'} or $re->{'USE'} or $re->{'DEL'} or $re->{'TREE'} or $re->{'uses'} or $re->{'deps'} );

  if( $re->{'NEW'} or $re->{'MAC'} and not -f "$re->{'HOME'}/DBM.db" or
      $re->{'LIN'} and not -f "$re->{'HOME'}/DBM.dir" or not -d $re->{'HOME'} ){
       $re->{'NEW'}++; Init_1( $re );
  }elsif( $re->{'COM'} or $re->{'S_OPT'} or defined $AR[1] and $name and $name->{'LIST'} ){
   $re->{'STDI'} = $name->{'KEN'} ? $AR[1] : defined $AR[1] ? lc $AR[1] : Died_1();
    $name->{'L_OPT'} = ( $name->{'KEN'} and -d "$ENV{'HOME'}/.JA_BREW" ) ? decode 'utf-8',$re->{'STDI'} :
     $name->{'KEN'} ? $re->{'STDI'} : $re->{'STDI'} =~ s|^/(.+)/$|$1| ? $re->{'STDI'} : "\Q$re->{'STDI'}\E";
      $re->{'S_OPT'} = $ref->{'S_OPT'} = $name->{'L_OPT'} if $re->{'S_OPT'};

  }elsif( $re->{'USE'} ){  $re->{'USE'} = lc $AR[1] || Died_1();
  }elsif( $ref->{'PRE'} ){ $ref->{'PRE'}= lc $AR[1] || Died_1();
  }elsif( $re->{'INF'} ){  $re->{'INF'} = $ref->{'INF'} = lc $AR[1] || Died_1();
  }elsif( $re->{'IS'} and $AR[1] ){ $re->{'INF'} = lc $AR[1];
  }elsif( $re->{'uses'} and $AR[1] ){ $re->{'use'} = lc $AR[1];
  }elsif( $re->{'deps'} and $AR[1] and $AR[1] ne '.' ){ $re->{'dep_s'} = lc $AR[1];
  }elsif( ( $re->{'ANA'} or $ref->{'ANA'} ) and $AR[1] ){ $re->{'ana'} = $ref->{'ana'} = lc $AR[1];
               $re->{'ana2'} = $AR[2] * 3 if $AR[1] !~ /^[0-8]$/ and $AR[2] and $AR[2] =~ /^[12]$/;
  }
  if( $re->{'DEL'} and $AR[2] and $AR[2] !~ /^\d+$/ ){ DB_1( $re );
   for(my $i=2;$i<@AR;$i++){
    die " $AR[$i] Not Formula or Cask\n" unless $re->{'HASH'}{$AR[$i]} or $re->{'DMG'}{$AR[$i]};
     $re->{"${AR[$i]}undel"} = $ref->{"${AR[$i]}undel"} = 1;
   }
  }
 Fork_1( $name,$re,$ref );
}

sub Fork_1{
my( $name,$re,$ref ) = @_;
 if( $re->{'LIN'} ){
  Init_1( $re ); Format_1( $re );
 }elsif( not $name or defined $re->{'S_OPT'} ){
  my $pid = fork;
  die " Not fork 1 : $!\n" unless defined $pid;
   if( $pid ){
    $ref->{'PID'} = $pid;
    Init_1( $ref );
   }else{
    Init_1( $re );
   }
   if( $pid ){
    waitpid $pid,0;
    Format_1( $ref );
   }else{
    Format_1( $re ); exit;
   }
 }else{ Init_1( $name ); Format_1( $name );
 }
}

sub Died_1{
  my $LC = `printf \$LC_ALL \$LC_CTYPE \$LANG 2>/dev/null` =~ /ja_jp\.utf-?8$/i;
  my $Lang = ( $LC and -d "$ENV{'HOME'}/.JA_BREW" ) ?
   "\n   # English display in Japanese version is argument EN
   # Uninstall rm -rf ~/.BREW_LIST ~/.JA_BREW $MY_BREW/share/zsh/site-functions/_bl
   # Then brew uninstall brew_list\n" :
    ( $LC and not -d "$ENV{'HOME'}/.JA_BREW" ) ?
   "\n   # Japanese Language -JA option
   # Uninstall rm -rf ~/.BREW_LIST $MY_BREW/share/zsh/site-functions/_bl
   # Then brew uninstall brew_list\n" :
   "\n   # Uninstall rm -rf ~/.BREW_LIST $MY_BREW/share/zsh/site-functions/_bl
   # Then brew uninstall brew_list\n";

  print"  Enhanced brew list : version 1.15_9\n   Option\n  -new\t:  creat new cache
  -l\t:  formula list : First argument Formula search : Second argument '.' Full-text search
  -i\t:  instaled formula list\n  -\t:  brew list command\n  -lb\t:  bottled install formula list
  -lx\t:  can't install formula list\n  -s\t:  type search formula name\n  -o\t:  brew outdated
  -co\t:  formula library display\n  -in\t:  formula require formula list
  -t\t:  formula require formula, display tree\n  -tt\t:  only require formula, display tree
  -u\t:  formula depend on formula\n  -ua\t:  formula depend on formula , all
  -ul\t:  formula depend on formula , item count
  -ud\t:  formula depend on formula , list : Second argument '.' not require dependencies Formula
  -g\t:  Independent Formula\n  -de\t:  uninstall, unnecessary formula, second argument not uninstall Formula
  -d\t:  uninstall, unnecessary formula, display tree, second argument not uninstall Formula
  -dd\t:  uninstall, unnecessary formula, display tree and order, second argument not uninstall Formula
  -ddd\t:  All deps uninstall, second argument not uninstall Formula
  -is\t:  Display in order of size\n  -g\t:  Independent formula
  -ai\t:  Analytics Data ( no argument, or argument [1-8] )\n";
 if( $^O eq 'darwin' ){
  print"   Only mac : Cask
  -c\t:  cask list : First argument Formula search : Second argument '.' Full-text search
  -ct\t:  cask tap list : First argument Formula search : Second argument '.' Full-text search
  -ci\t:  instaled cask list\n  -cx\t:  can't install cask list\n  -cs\t:  some name cask and formula
  -cd\t:  Display required list casks\n  -ac\t:  Analytics Data ( no argument, or argument 1,2 )
  -ctp\t:  Font quickLook preview list\n  -p\t:  Font quickLook preview : p mark only ( unstable )\n";
 }
 die $Lang;
}

sub Init_1{
my $re = shift; my( $list,$pid ) = [];
 if( $re->{'NEW'} ){
  die " \033[31mNot connected\033[0m\n"
   if system 'curl -k https://formulae.brew.sh/formula >/dev/null 2>&1';
    system '~/.BREW_LIST/font.sh 1' if -d "$re->{'HOME'}/LOCK";
     print STDERR " exist \033[31mLOCK\033[0m\n" if -d "$re->{'HOME'}/LOCK";
  $SIG{'INT'} = $SIG{'QUIT'} = $SIG{'TERM'} = sub{ my( $not ) = Doc_1(); die "\x1B[?25h$not" };
   Wait_1( $re );
 }
  if( ( not $re->{'TREE'} or $re->{'TREE'} < 2 ) and not $re->{'ANA'} and not $re->{'COL'} ){
   DB_1( $re ) unless $re->{'PRE'} or $re->{'HASH'} or $re->{'DMG'};
    DB_2( $re ) unless $re->{'BL'} or defined $re->{'S_OPT'} or $re->{'COM'};
  }
  if( $re->{'INF'} and not $re->{'COL'} or $re->{'USE'} or $re->{'dep_s'} or $re->{'ANA'} or $re->{'use'} ){
   my $cat = $re->{'MAC'} ? [`awk '{print \$1}' ~/.BREW_LIST/brew.txt 2>/dev/null || echo 1
                              awk '{print \$1}' ~/.BREW_LIST/cask.txt 2>/dev/null || echo 1`]:
                            [`awk '{print \$1}' ~/.BREW_LIST/brew.txt 2>/dev/null`];
   @$cat ? Like_1( $re,[\$re->{'INF'},\$re->{'USE'},\$re->{'dep_s'},\$re->{'ana'},\$re->{'use'}],$cat ) :
    die " \033[33mNo file...\033[0m tyep bl -new\n";
  }
  Dele_1( $re ) if $re->{'DEL'} and $re->{'DEL'} < 2;
   Info_1( $re ) if $re->{'INF'};
    return if $re->{'TREE'};
  unless( $re->{'ANA'} or $re->{'COM'} or $re->{'deps'} or $re->{'PRE'} ){
    $list = ( defined $re->{'S_OPT'} or $re->{'BL'} and $re->{'CAS'} ) ? Dirs_1( $re->{'CEL'},1 ) :
     ( $re->{'TOP'} or $re->{'IS'} or $re->{'BL'} or $re->{'uses'} ) ? Dirs_1( $re->{'CEL'},3 ) :
       Dirs_1( $re->{'CEL'},0,$re );
   @$list = $re->{'OS'}{"$re->{'USE'}uses"} ? split '\t',$re->{'OS'}{"$re->{'USE'}uses"} : () if $re->{'USE'};
    $re->{'cask'} = [] if $re->{'USE'} or $re->{'BL'};
   if( $re->{'MAC'} and $re->{'USE'} ){
    my @list1 = split '\t',$re->{'OS'}{"$re->{'USE'}u_form"} if $re->{'OS'}{"$re->{'USE'}u_form"};
    my @list2 = split '\t',$re->{'OS'}{"$re->{'USE'}u_cask"} if $re->{'OS'}{"$re->{'USE'}u_cask"};
     @{$re->{'cask'}} = ( @list1,@list2 );
   }
  }
 if( @$list and ( $re->{'IS'} and ( not $re->{'INF'} or $re->{'HASH'}{$re->{'INF'}} ) or
                  $re->{'TOP'} and not $re->{'PID'} or $re->{'uses'} and not $re->{'use'} ) ){
  $SIG{'INT'} = $SIG{'QUIT'} = $SIG{'TERM'} = sub{ rmdir "$re->{'HOME'}/WAIT"; die "\x1B[?25h" };
   $re->{'PID2'} = fork;
    die " IS Not fork : $!\n" unless defined $re->{'PID2'}; $pid = 1;
 }
 if( $pid and not $re->{'PID2'} ){ Wait_1( $re,1 );
 }else{
  $re->{'COM'} ? Command_1( $re ) : ( $re->{'BL'} and $re->{'FOR'} or $re->{'USE'} ) ? Brew_1( $re,$list ) :
   $re->{'TOP'} ? Top_1( $re,$list ) : $re->{'IS'} ? Size_1( $re,$list ) : $re->{'ANA'} ? Ana_1( $re ) :
    $re->{'uses'} ? Brew_2( $re ) : $re->{'deps'} ? Brew_3( $re,'' ) : File_1( $re,$list );
 }
}

sub Doc_1{
 my( $dok,$not,@ten ) = $Locale ?
  ( "\r  \033[36m✔︎\033[0m : Creat new cache          \n",
    "\r  \033[31m✖︎\033[0m : Can not Create           \n",('⣸','⣴','⣦','⣇','⡏','⠟','⠻','⢹') ) :
  ( "\r  \033[36mo\033[0m : Creat new cache          \n",
    "\r  \033[31mx\033[0m : Can not Create           \n",('|','/','-','\\','|','/','-','\\') );
 $not,$dok,@ten;
}

sub Wait_1{
my( $re,$loop ) = @_; my $pid;
 system 'mv ~/.BREW_LIST ~/BREW_LIST$$' if -d $re->{'HOME'} and not -f $re->{'TXT'};
  mkdir $re->{'HOME'};
   mkdir "$re->{'HOME'}/WAIT";
  my( $not,$dok,@ten ) = Doc_1;
  unless( $loop ){
   $pid = fork;
    die " Wait Not fork : $!\n" unless defined $pid;
  }
  if( $pid or $loop ){
   if( ( $loop or not -d "$re->{'HOME'}/LOCK" ) and -t STDOUT ){
    print STDERR "\x1B[?25l";
    if( $^O eq 'linux' or $loop or $re->{'TEN'} ){ my $i = 0;
     my $name = $loop ? 'Please wait' : 'Makes new cache';
      while(1){ $i = $i % 8; my $c = ( (rand 6) + 1 ) >> 0;
       -d "$re->{'HOME'}/WAIT" ?
        print STDERR "\r  \033[3${c}m$ten[$i]\033[0m : $name" : last;
         $i++; select undef,undef,undef,0.1;
      }
    }else{ my $i = 0; my $ma = '';
      while(1){
      printf STDERR "\r '\033[33m%-20s\033[0m' [%2d/20]",$ma,$i;
       last unless -d "$re->{'HOME'}/WAIT";
        if( -d "$re->{'HOME'}/$i" ){
         while(1){
          last unless -d "$re->{'HOME'}/$i";
         } $i++; $ma .= '#';
        }
      }
    }
    unless( $loop ){
     waitpid $pid,0;
     ( $re->{'MAC'} and -f "$re->{'HOME'}/DBM.db" or
       $re->{'LIN'} and -f "$re->{'HOME'}/DBM.dir" ) ? ( print "\x1B[?25h$dok" and exit ) : die "\x1B[?25h$not";
    }else{ print "\r",$re->{'SPA'}x2,"\r\x1B[?25h"; }
   } exit;
  }else{
   Tied_1( $re ) unless -d "$re->{'HOME'}/LOCK";
    $re->{'TEN'} ? system '~/.BREW_LIST/font.sh 1 2' : system '~/.BREW_LIST/font.sh 0 1';
     exit;
  }
}

sub DB_1{
my $re = shift;
 if( $re->{'FOR'} or $re->{'DEP' } ){
  opendir my $dir,$re->{'BIN'} or die " DB_1 $!\n";
   for my $ls(readdir $dir){ next if $ls =~ /^\./;
    my $hand = readlink "$re->{'BIN'}/$ls";
     next if not $hand or $hand !~ m|^\.\./Cellar/|;
    my( $an,$bn ) = $hand =~ m|^\.\./Cellar/([^/]+)/(.+)|;
     $re->{'HASH'}{$an} = $bn;
   }
  closedir $dir;
 }
 if( $re->{'CAS'} or $re->{'CELS'} ){
  my $mem = $re->{'CEL'}, $re->{'CEL'} = $re->{'CELS'} if $re->{'CELS'};
  my $dirs = Dirs_1( $re->{'CEL'},3 );
  for(my $in=0;$in<@$dirs;$in++){
   if( $$dirs[$in] and -d "$re->{'CEL'}/$$dirs[$in]/.metadata" ){
    my $meta = Dirs_1( "$re->{'CEL'}/$$dirs[$in]/.metadata",3 );
     $re->{'DMG'}{$$dirs[$in]} = $$meta[0];
   }
  } $re->{'CEL'} = $mem if $re->{'CELS'};
 }
}

sub DB_2{
 my $re = shift;
 tie my %tap,'NDBM_File',"$re->{'HOME'}/DBM",O_RDONLY,0 or die " Not read DBM $!\n";
 $re->{'OS'} = \%tap;
}

sub Dirs_1{
my( $url,$ls,$re ) = @_; my( $an,$bn )  = ( [],[] );
 return $an unless -d $url;
 opendir my $dir_1,$url or die " Dirs_1 $!\n";
  for my $hand(readdir $dir_1){ next if $hand =~ /^\./;
   $re->{'FILE'} .= " File exists $url/$hand\n" if -f "$url/$hand" and not $ls;
    if( $ls != 2 ){ next unless -d "$url/$hand"; }
   $ls == 1 ? push @$an," $hand\n" : push @$an,$hand;
  }
 closedir $dir_1;
  @$an = sort @$an;
   return $an if $ls;

 for(my $in=0;$in<@$an;$in++){
  push @$bn," $$an[$in]\n";
  opendir my $dir_2,"$url/$$an[$in]" or die " Dirs_2 $!\n";
   /^\./ ? next : push @$bn,"$_\n" for readdir $dir_2;
  closedir $dir_2;
 }
 $bn;
}

sub Proc_1{
my( $re,$list,$cou ) = @_; my( $c,$d,$e,$m,@an1,@an2,@an3,@an4,$deps ) = ( 0,1,2,3 );
 for(my $i=0;$i<@$list;$i++){
  next if $$list[$i] eq 'glibc' or $$list[$i] eq 'linux-headers@5.15';
   if( $re->{'OS'}{"$$list[$i]uses"} and $re->{'OS'}{"$$list[$i]uses_proc"} ){
           my $proc = split '\t',$re->{'OS'}{"$$list[$i]uses_proc"};
              $deps = split '\t',$re->{'OS'}{"$$list[$i]uses"};
              $deps = $proc if $deps < $proc;
   }elsif( $re->{'OS'}{"$$list[$i]uses"} ){ $deps = split '\t',$re->{'OS'}{"$$list[$i]uses"};
   }elsif( $re->{'OS'}{"$$list[$i]uses_proc"} ){ $deps = split '\t',$re->{'OS'}{"$$list[$i]uses_proc"};
   }else{ $deps = 0; }
    if( $m >= $c and $d >= $c and $e >= $c ){ push @an1,$$list[$i]; $c += $deps;
    }elsif( $m >= $d and $e >= $d and $c >= $d ){ push @an2,$$list[$i]; $d += $deps;
    }elsif( $m >= $e and $d >= $e and $c >= $e ){ push @an3,$$list[$i]; $e += $deps;
    }elsif( $e >= $m and $d >= $m and $c >= $m ){ push @an4,$$list[$i]; $m += $deps; }
 }
  if( $cou and $re->{'LIN'} ){ push @an1,'glibc'; push @an2,'linux-headers@5.15'; }
    my $par = sub{ my( $re,$an,$hand ) = @_;
                   for my $ls(@$an){ my( @AN,%HA );
                    Uses_1( $re,$ls,\%HA,\@AN );
                     push @{$re->{$ls}},@AN if $hand;
                      $AN[0] ||= 0,print"$ls\t@AN\n" unless $hand;
                   } exit unless $hand;
                   while(<$hand>){ my($name,$data) = /([^\t]+)\t(.+)/;
                    @{$re->{$name}} = $data ? split '\s',$data : ();
                   } close $hand;
                 };

 if( open my $FH,'-|' ){
   if( open my $CH,'-|' ){
     $par->( $re,\@an1,$CH );
    die " can't open process 1\n" if $?;
   }else{ exit unless @an3;
     $par->( $re,\@an3 );
   }
    $par->( $re,[],$FH );
  if( $? ){ waitpid $re->{'PID2'},0 if rmdir "$re->{'HOME'}/WAIT"; die " can't open process 3\n"; }
 }else{ exit unless @an2;
   if( open my $DH,'-|' ){
     $par->( $re,\@an2,$DH );
    die " can't open process 2\n" if $?;
   }else{ exit unless @an4;
     $par->( $re,\@an4 );
   }
  for my $ls(@an2,@an4){ $re->{$ls}[0] ||= 0;
    print"$ls\t@{$re->{$ls}}\n";
  } exit;
 }
}

sub Leng_1{
my( $spa,$name ) = @_;
 if( $spa < length $$name ){
  my $ti = $spa - 4;
   $$name =~ s/^(.{$ti}).*/$1.../;
 }
 my $spa1 = ( $spa -length $$name ) >> 1;
 $$name = ' 'x$spa1.$$name.' 'x$spa1;
 $$name = ' '.$$name if length $$name < $spa;
}

sub Ana_1{
 my $re = shift; my @an;
 $re->{'NEW'}++, Init_1( $re ) unless -f $re->{'CAN'};
  my $mem = $re->{'ana'} if $re->{'ana'} and $re->{'ana'} !~ /^[1-8]$/;
 $re->{'ana'} = 0 if not $re->{'ana'} or $re->{'ana'} and $re->{'ana'} !~ /^[1-8]$/;
  $re->{'ana'} = $re->{'ana2'} if $re->{'ana2'};
  open my $dir,'<',$re->{'CAN'} or die " ana $!\n";
   while(<$dir>){ chomp;
    my( $ls,$ls1,$ls2,$ls3,$co1,$co2,$co3,$ls4,$ls5,$ls6,$eq1,$eq2,$eq3,$ls7,$ls8,$ls9,$er1,$er2,$er3 ) = split '\t';
    my $co = $re->{'ana'} == 1 ? $ls1 : $re->{'ana'} == 2 ? $ls2 : $re->{'ana'} == 3 ? $ls6 :
             $re->{'ana'} == 4 ? $ls4 : $re->{'ana'} == 5 ? $ls5 : $re->{'ana'} == 6 ? $ls9 :
             $re->{'ana'} == 7 ? $ls7 : $re->{'ana'} == 8 ? $ls8 :$ls3;
    if( $re->{'ana'} >= 3 and $re->{'ana'} <= 5 ){
                   my @mem = ( $ls1,$ls2,$ls3 );
        ( $ls1,$ls2,$ls3 ) = ( $ls4,$ls5,$ls6 );
        ( $ls4,$ls5,$ls6 ) = @mem;
                      @mem = ( $co1,$co2,$co3 );
        ( $co1,$co2,$co3 ) = ( $eq1,$eq2,$eq3 );
        ( $eq1,$eq2,$eq3 ) = @mem;
    }elsif( $re->{'ana'} >= 6 and $re->{'ana'} <= 8 ){
                   my @mem = ( $ls1,$ls2,$ls3 );
        ( $ls1,$ls2,$ls3 ) = ( $ls7,$ls8,$ls9 );
        ( $ls7,$ls8,$ls9 ) = @mem;
                      @mem = ( $co1,$co2,$co3 );
        ( $co1,$co2,$co3 ) = ( $er1,$er2,$er3 );
        ( $er1,$er2,$er3 ) = @mem;
    }
    if( $co ){
     $an[$co]  = $ls;
     $an[$co] .= $ls1 ? "\t$ls1" : "\t";
     $an[$co] .= $ls2 ? "\t$ls2" : "\t";
     $an[$co] .= $ls3 ? "\t$ls3" : "\t";
     $an[$co] .= $co1 ? "\t$co1" : "\t";
     $an[$co] .= $co2 ? "\t$co2" : "\t";
     $an[$co] .= $co3 ? "\t$co3" : "\t";
     if( $re->{'FOR'} ){
      $an[$co] .= $ls4 ? "\t$ls4" : "\t";
      $an[$co] .= $ls5 ? "\t$ls5" : "\t";
      $an[$co] .= $ls6 ? "\t$ls6" : "\t";
      $an[$co] .= $eq1 ? "\t$eq1" : "\t";
      $an[$co] .= $eq2 ? "\t$eq2" : "\t";
      $an[$co] .= $eq3 ? "\t$eq3" : "\t";
      $an[$co] .= $ls7 ? "\t$ls7" : "\t";
      $an[$co] .= $ls8 ? "\t$ls8" : "\t";
      $an[$co] .= $ls9 ? "\t$ls9" : "\t";
      $an[$co] .= $er1 ? "\t$er1" : "\t";
      $an[$co] .= $er2 ? "\t$er2" : "\t";
      $an[$co] .= $er3 ? "\t$er3" : "\t";
     }
    }
   }
  close $dir;
   my $tput = `tput cols`;
    my $line = $tput >= 84 ? 83 : $tput - 2;
     my $spa = $tput >= 84 ? 43 : ($tput - 41) > 0 ? $tput - 41 : 0;
      my $size = $tput >= 84 ? ($tput - 84) >> 1 : 0;
   my @line = $Locale ? ( '│','┬','┴','┼','─','├','┤','┌','┐','└','┘' ):
                        ( '|','-','-','-','-',' ',' ',' ',' ',' ',' ' );
    my $line1 = "$line[4]"x$spa;
     my $line2 = "$line[4]"x12;
      my $line3 = (' 'x$size).('-'x($line * 1.15))."\n";
    my $spr1 = "%${size}s$line[5]$line1$line[3]$line2$line[3]$line2$line[3]$line2$line[6]";
     my $spr2 = "%${size}s$line[0]%${spa}s$line[0] %10s $line[0] %10s $line[0] %10s $line[0]";

   my $ana  = ( $re->{'MAC'} or -t STDOUT ) ?
              (' 'x$size)."$line[7]$line1$line[1]$line2$line[1]$line2$line[1]$line2$line[8]\n" : $line3;
      $ana .= (' 'x$size)."$line[0]".(' 'x$spa)."$line[0]      30d   $line[0]      90d   $line[0]     365d   $line[0]\n";

   my( $in1,$in2,$in3 ) = ( $re->{'ana'} >= 3 and $re->{'ana'} <= 5 ) ?
     ('install on request ','install ','build-error ') : ( $re->{'ana'} >= 6 and $re->{'ana'} <= 8 ) ?
     ('build-error ','install on request ','install ') : ('install ','install on request ','build-error ');
   $re->{'ana'} = 0 if $re->{'ana2'};
 for my $an(@an){
  next unless $an;
   my( $ls,$ls1,$ls2,$ls3,$co1,$co2,$co3,$ls4,$ls5,$ls6,$eq1,$eq2,$eq3,$ls7,$ls8,$ls9,$er1,$er2,$er3 ) = split '\t',$an;
   if( not $mem or $re->{'ana'} or $mem and $mem eq $ls ){
    Leng_1( $spa,\$ls ) if $spa >= 12;
    $ls = "\033[36m$ls\033[0m" if -t STDOUT;
     if( $re->{'FOR'} ){
      $ana .= ( $re->{'MAC'} or -t STDOUT ) ? sprintf "$spr1\n",' 'x$size : $line3;
      $ana .= sprintf "%${size}s$line[0]%${spa}s$line[0]%8s    $line[0]%8s    $line[0]%8s    $line[0]\n$spr2\n",
                      ' 'x$size,$ls,$ls1,$ls2,$ls3,
                      ' 'x$size,$in1,$co1,$co2,$co3;
      $ana .= sprintf "%${size}s$line[0]%${spa}s$line[0]%8s    $line[0]%8s    $line[0]%8s    $line[0]\n$spr2\n",
                      ' 'x$size,'',$ls4,$ls5,$ls6,
                      ' 'x$size,$in2,$eq1,$eq2,$eq3;
      $ana .= sprintf "%${size}s$line[0]%${spa}s$line[0]%8s    $line[0]%8s    $line[0]%8s    $line[0]\n$spr2\n",
                      ' 'x$size,'',$ls7,$ls8,$ls9,
                      ' 'x$size,$in3,$er1,$er2,$er3;
     }else{
      $ana .= sprintf "$spr1\n",' 'x$size;
      $ana .= sprintf "%${size}s$line[0]%${spa}s$line[0]%9s   $line[0]%9s   $line[0]%9s   $line[0]\n$spr2\n",
                      ' 'x$size,$ls,$ls1,$ls2,$ls3,
                      ' 'x$size,'install ',$co1,$co2,$co3;
     }
   }
 }
     $ana .= ( $re->{'MAC'} or -t STDOUT ) ?
             (' 'x$size)."$line[9]$line1$line[2]$line2$line[2]$line2$line[2]$line2$line[10]\n" : $line3;
  if( $mem and $ana =~ /install / ){
   print $ana;
  }elsif( $ana =~ /install / ){
   open my $pipe,'|-','less -RX' or die " can't exec command\n";
    print $pipe $ana;
   close $pipe;
  }
 Nohup_1( $re );
}

sub Size_1{
 my( $re,$list ) = @_; my( %AR,@data,$size,$ls1,$ls2,$c );
  if( $re->{'INF'} and not $re->{'HASH'}{$re->{'INF'}} ){ exit;
  }elsif( $re->{'INF'} and $re->{'HASH'}{$re->{'INF'}} ){
   @data = split '\t',$re->{"$re->{'INF'}deps"} if $re->{"$re->{'INF'}deps"};
    push @data,$re->{'INF'};
  }
   my $an = @data ? \@data : $list;
    exit unless @$an;
     my $tput = `tput cols`;
      my $spa = $tput >= 88 ? 40 : ($tput - 48) > 0 ? $tput - 48 : 0;
   for(my $i=0;$i<@$an;$i++){
    @{$AR{$$an[$i]}} = glob "$re->{'CEL'}/$$an[$i]/*";
     if( $i & 1 ){ $ls2 .= "$re->{'CEL'}/$$an[$i] ";
     }else{ $ls1 .= "$re->{'CEL'}/$$an[$i] "; }
   }
   if( open my $FH,'-|' ){
    @data = `du -ks $ls1`;
     push @data,<$FH>;
      close $FH;
    if( $? ){ waitpid $re->{'PID2'},0 if rmdir "$re->{'HOME'}/WAIT"; die " can't open process 1\n"; }
   }else{ print`du -ks $ls2` if $ls2; exit; }
   waitpid $re->{'PID2'},0 if rmdir "$re->{'HOME'}/WAIT";
    my $cmp = sub{ $_[0] =~ /(\d+)\s/; $1; };
   for(sort{$cmp->($b) <=> $cmp->($a)}@data){ my $utime; $c++;
    my( $cou,$name ) = m|(\d+)\s.+/(.+)|;
    for my $json(@{$AR{$name}}){
     if( -f "$json/INSTALL_RECEIPT.json" ){
      open my $dir,'<',"$json/INSTALL_RECEIPT.json" or die " JSON $!\n";
       while(<$dir>){ last if( $utime ) = /^.*"time":[^0-9]*([0-9]+),.*/ }
      close $dir;
     }
    } $utime = $utime || 0;
     my $time = [localtime($utime)];
      my $timer = sprintf "%04d/%02d/%02d",$time->[5]+=1900,++$time->[4],$time->[3];
       $size += $cou = sprintf "%.3f",$cou /= 1024;
        Tap_2( $re,\$name );
         Leng_1( $spa,\$name ) if $spa >= 5;
     printf"%-${spa}s %8s%12s%3s%22s\n",$name,"size  : ","$cou MB","   ","install  :  $timer"
   }
  printf" Totsl Size  %.2f MB  item %d\n",$size,$c if -t STDOUT;
 Nohup_1( $re );
}

sub Top_1{
my( $re,$list ) = @_; my $top;
 Proc_1( $re,$list );
 for my $ls(@$list){
  next if $ls eq 'glibc' or $ls eq 'linux-headers@5.15';
  if( @{$re->{$ls}} and @{$re->{$ls}} < 2 ){
   my @BUI = split '\t',$re->{'OS'}{"${ls}build"} if $re->{'OS'}{"${ls}build"};
   Tap_2( $re,\$ls ) if $re->{'FOR'};
    for my $bui(@BUI){ my $build = $bui;
     Tap_2( $re,\$bui ) if $re->{'FOR'};
      $ls .= " : $bui" if $re->{'HASH'}{$build};
    }
   $ls =~ s/^([^:]+)\s:\s(.+)/$1 [build] => $2\n/ ? $top .= $ls : Mine_1( $ls,$re,0 );
  }
 }
  waitpid $re->{'PID2'},0 if not $re->{'PID'} and rmdir "$re->{'HOME'}/WAIT";
 print "$top" if $top;
}

sub Brew_1{
my( $re,$list ) = @_; my( %HA,@AN );
 return unless @$list or @{$re->{'cask'}};
  for(my $i=0;$i<@$list;$i++){ my $tap = $list->[$i];
   Tap_2( $re,\$list->[$i] ) if $re->{'FOR'};
    ( ( $re->{'DMG'}{$tap} or $re->{'HASH'}{$tap} ) and not $re->{'USE'} ) ? Mine_1( $list->[$i],$re,0 ) :
    ( ( $re->{'DMG'}{$tap} or $re->{'HASH'}{$tap} ) and $re->{'USE'} and not $re->{'USES'} ) ?
      Uses_1( $re,$tap,\%HA,\@AN ) : $re->{'USES'} ? push @AN,$tap : 0;
  }
 if( $re->{'USE'} ){ my @cask;
  $re->{'KAI'} = 1 unless @AN = sort @AN;
   unshift @AN,' ==> Formula' if @AN;
   $re->{'DMG'}{$_} ? push @cask,$_ : 0 for @{$re->{'cask'}};
    if( not $re->{'USES'} and @cask ){ push @AN,' ==> Cask',@cask;
    }elsif( $re->{'USES'} and @{$re->{'cask'}} ){ push @AN,' ==> Cask',@{$re->{'cask'}}; }
  for my $an(@AN){ Mine_1( $an,$re,0 ) }
 }
}

sub Brew_2{
my $re = shift; my( $ls,@an,%ha );
 my $tput = `tput cols`;
  my $spa = $tput >= 66 ? 44 : ($tput - 22) > 0 ? $tput - 22 : 0;
 if( $re->{'use'} ){
  Uses_1( $re,$re->{'use'},\%ha,\@an) ;
   if( @an ){
    Tap_2( $re,\$re->{'use'} );
     Leng_1( $spa,\$re->{'use'} ) if $spa >= 5;
      $ls = sprintf"%${spa}s uses  :%4s formula\n",$re->{'use'},@an - 1;
   }
 }else{
  push @an,$_ for (sort keys %{$re->{'HASH'}});
   Proc_1( $re,\@an,1 );
  for my $key(sort keys %{$re->{'HASH'}}){ my $keys = $key;
   Tap_2( $re,\$keys );
    Leng_1( $spa,\$keys ) if $spa >= 5;
     $ls .= sprintf"%${spa}s uses  :%4s formula\n",$keys,@{$re->{$key}} - 1;
  }
  waitpid $re->{'PID2'},0 if rmdir "$re->{'HOME'}/WAIT";
 }
 print"$ls" if $ls;
 Nohup_1( $re );
}

sub Brew_3{
my( $re,$ls ) = @_; my( @AN,$mine,$in );
 my $brew = $ls ? 'DMG' : 'HASH';
 for my $key(sort keys %{$re->{$brew}}){
  next if $re->{'dep_s'} and $re->{'dep_s'} ne $key;
  $re->{'LENG'} = 0;
  $re->{'INF'} = $key;
   Info_1( $re,0,0,\@AN );
    Tap_2( $re,\$key );
     @AN = sort @AN unless $ls;
     if( -t STDOUT and @AN and not $in ){ $in++;
      ( $re->{'dep_s'} and $ls ) ? print" ==> Cask\n" : $ls ? print"\n ==> Cask\n" : print" ==> Formula\n";
     }
      print"$re->{'NOT'}" if $re->{'NOT'} and @AN and not $re->{'KEN'};
       for my $len( @AN ){
        $re->{'LEN'}{$len} = length $len;
         $re->{'LEN1'} = $re->{'LEN'}{$len} if $re->{'LEN1'} < $re->{'LEN'}{$len};
          push @{$re->{'ARR'}},$len;
       }
     ( not @AN and $re->{'NOT'} ) ? $mine .= "$re->{'NOT'}$ls   Not require dependencies...\t: $key\n" :
       not( @AN or $re->{'NOT'} ) ? $mine .= "$ls   Not require dependencies...\t: $key\n" : 0;
     unless( $re->{'KEN'} ){
      -t STDOUT ? print" \033[36m$key\033[0m : depends\n" : print" $key : depends\n" if @AN;
       Format_1( $re ) if @AN;
        print '_' x $re->{'LENG'},"\n" if -t STDOUT and @AN and not $re->{'dep_s'};
     }
    $re->{"deps$_"} = $re->{'LEN1'} = 0 for @AN;
   @AN = @{$re->{'ARR'}} = ();
  $re->{'NOT'} = '';
 }
 print $mine if $re->{'KEN'} and $mine;
 Brew_3( $re,' ' ) unless $ls or $re->{'LIN'} or not $re->{'DMG'};
 Nohup_1( $re );
}

sub Like_1{
my( $re,$name,$cat ) = @_; my( %HA,%HAN,@ARR );
 waitpid( $re->{'PID'},0 ) if $re->{'PID'};
  $name = $$_ ? $_ : next for @$name;
   return if ref $name eq 'ARRAY';
 unless( $cat ){
  $HA{$_}++ for split '\t',$re->{'OS'}{'fontlist'};
 }else{
  if( $re->{'USE'} and not $re->{'USES'} or $re->{'DEL'} and not $re->{'DDD'} or $re->{'use'} ){
   for my $key1(keys %{$re->{'HASH'}}){
    if( $re->{'OS'}{"${key1}deps"} ){
     $re->{'DEL'} ? $HAN{$_}++ : $HA{$_}++ for split '\t',$re->{'OS'}{"${key1}deps"};
    }
   }
   for my $key2(keys %{$re->{'DMG'}}){
    if( $re->{'OS'}{"${key2}d_cask"} ){
     $re->{'DEL'} ? $HAN{$_}++ : $HA{$_}++ for split '\t',$re->{'OS'}{"${key2}d_cask"};
    }
    if( $re->{'OS'}{"${key2}formula"} ){
     $re->{'DEL'} ? $HAN{$_}++ : $HA{$_}++ for split '\t',$re->{'OS'}{"${key2}formula"};
    }
   }
  }
  if( $re->{'USES'} ){
   for my $c1(@$cat){ chomp $c1;
    $HA{$c1}++ if $re->{'OS'}{"${c1}uses"};
    $HA{$c1}++ if $re->{'OS'}{"${c1}u_cask"};
    $HA{$c1}++ if $re->{'OS'}{"${c1}u_form"};
   }
  }elsif( $re->{'DEL'} and not $re->{'DDD'} ){
   $re->{'OS'}{"${_}deps"} ? push @ARR,$_ : 0 for keys %{$re->{'HASH'}};
    for my $key(keys %{$re->{'DMG'}}){ my $ls;
     $ls = push @ARR,$key if $re->{'OS'}{"${key}d_cask"};
     push @ARR,$key if $re->{'OS'}{"${key}formula"} and not $ls;
    }
  }elsif( $re->{'dep_s'} ){
   $re->{'OS'}{"${_}deps"} ? $HA{$_}++ : 0 for keys %{$re->{'HASH'}};
   $re->{'OS'}{"${_}d_cask"} ? $HA{$_}++ : 0 for keys %{$re->{'DMG'}};
  }elsif( $re->{'COM'} or $re->{'IS'} ){
    $HA{$_}++ for keys %{$re->{'HASH'}};
  }elsif( $re->{'TREE'} or $re->{'LINK'} ){
   for my $c2(@$cat){ chomp $c2;
    if( $re->{'FOR'} ){
     $HA{$c2}++ if $re->{'OS'}{"${c2}deps"};
     $HA{$c2}++ if $re->{'OS'}{"${c2}deps_b"} and not $re->{'OS'}{"${c2}$OS_Version"};
    }
    $HA{$c2}++ if $re->{'OS'}{"${c2}d_cask"};
   }
  }elsif( $re->{'ANA'} ){ my $min;
   if( $re->{'FOR'} ){ return if $$name =~ /^[1-8]$/;
    for my $c3(@$cat){ chomp $c3;
      last if $min and $min gt $c3;
       $min = $c3;
        $HA{$c3}++;
    }
   }else{ return if $$name =~ /^[12]$/;
    for(my $i=0;$i<@$cat;$i++){
     $$cat[$i] lt $$cat[$i+1] ? next : $i++,$min++ unless $min;
      chomp $$cat[$i];
       $HA{$$cat[$i]}++;
    }
   }
  }
 }
 $HA{$_} = $HAN{$_} ? next : 1 for @ARR; @ARR = ();
 for my $key(sort keys %HA){
  if( $key =~ /^\Q$$name\E$/ ){ return;
  }elsif( not $cat and $key =~ /\Q$$name\E/ or $key =~ /^\Q$$name\E/ ){
   $re->{'LEN'}{$key} = length $key;
    $re->{'LEN1'} = $re->{'LEN'}{$key} if $re->{'LEN1'} < $re->{'LEN'}{$key};
   push @ARR,$key;
  }
 }
 if( @ARR and @ARR < 2 ){
  $$name = $ARR[0];
   print" $$name...\n" if $cat and not $re->{'dep_s'};
 }else{
  if( @ARR ){
   $re->{'LIKE'} = print"\033[33m much...\033[0m\n";
    $re->{'ARR'} = \@ARR;
     $re->{'LIST'} = 0;
      Format_1( $re );
  } exit if $re->{'LIKE'};
 }
}

sub Prew_1{
my $re = shift;
 unless( $re->{'OS'}{"$re->{'PRE'}font"} ){
  Like_1( $re,[\$re->{'PRE'}] ) if $re->{'OS'}{'fontlist'};
   exit unless $re->{'OS'}{"$re->{'PRE'}font"};
  print" $re->{'PRE'}...\n"
 unless -f "$re->{'HOME'}/master.ttf" or -f "$re->{'HOME'}/master.otf" or -f "$re->{'HOME'}/master.dfont";
 }
  my( $type ) = $re->{'OS'}{"$re->{'PRE'}font"} =~ /.+\.(.+)$/;
 die " exist mater.$type please type : bl -new\n"
  if -f "$re->{'HOME'}/master.ttf" or -f "$re->{'HOME'}/master.otf" or -f "$re->{'HOME'}/master.dfont";
 die " \033[31mNot connected\033[0m\n"
  if system "curl -sLo ~/.BREW_LIST/master.$type $re->{'OS'}{\"$re->{'PRE'}font\"} 2>/dev/null &&\
             qlmanage -p ~/.BREW_LIST/master.$type >/dev/null 2>&1";
  unlink "$re->{'HOME'}/master.$type";
 Nohup_1( $re );
}

sub Uses_1{
my( $re,$tap,$HA,$AN ) = @_;
 for my $ls(split '\t',$tap){
  $HA->{$ls}++;
   push @$AN,$ls if( $re->{'HASH'}{$ls} or $re->{'DMG'}{$ls} ) and $HA->{$ls} < 2;
   Uses_1( $re,$re->{'OS'}{"${ls}uses"},$HA,$AN ) if $re->{'OS'}{"${ls}uses"} and $re->{'HASH'}{$ls};
   Uses_1( $re,$re->{'OS'}{"${ls}u_form"},$HA,$AN ) if $re->{'OS'}{"${ls}u_form"} and $re->{'HASH'}{$ls};
   Uses_1( $re,$re->{'OS'}{"${ls}u_cask"},$HA,$AN ) if $re->{'OS'}{"${ls}u_cask"} and $re->{'DMG'}{$ls};
 }
}

sub Dele_1{
my $re = shift; my( @AN,%HA,@an,$do );
 print" \033[33mexists Formula and Cask...\033[0m\n"
  if $re->{'FOR'} and $re->{'OS'}{"$re->{'INF'}so_name"} and -t STDOUT;
  exit unless $re->{'HASH'}{$re->{'INF'}} or $re->{'DMG'}{$re->{'INF'}};
 Uses_1( $re,$re->{'INF'},\%HA,\@AN ) if $re->{'FOR'};
  $_ eq $re->{'INF'} ? next : push @an,$_ for sort @AN;
   $re->{'HASH'}{$_} ? print"required formula ==> $_\n" : print"required cask ==> $_\n" for @an;

 unless( @an ){ @AN = ();
  unless( $re->{'CAS'} ){
   $SIG{'INT'} = $SIG{'QUIT'} = $SIG{'TERM'} = sub{ rmdir "$re->{'HOME'}/WAIT"; die "\x1B[?25h" };
    $re->{'PID2'} = fork;
     die " Dele Not fork : $!\n" unless defined $re->{'PID2'};
  }
  unless( $re->{'PID2'} or $re->{'CAS'} ){ Wait_1( $re,1 );
  }else{
   Info_1( $re,0,0,\@AN );
    Proc_1( $re,\@AN );
     my @list1 = sort @AN;
   for my $brew(@list1){
    next if $brew eq 'glibc' or $brew eq 'linux-headers@5.15';
    exit unless ref $re->{$brew};
     my @list2 = sort @{$re->{$brew}};
     my $i = 0; my $e = 0;
     for(;$i<@list2;$i++){ my $flag;
      next if $list2[$i] eq $brew or $list2[$i] eq $re->{'INF'};
       for(;$e<@list1;$e++){
        last if $list1[$e] eq $list2[$i];
        $flag++, last if $list1[$e] gt $list2[$i];
       }
       $flag++ if $list1[$#list1] lt $list2[$i];
      last if $flag;
     }
    $re->{"${brew}delet"} = $do = 1 unless $list2[$i];
   }
    waitpid $re->{'PID2'},0 if not $do and rmdir "$re->{'HOME'}/WAIT";
   if( $re->{'LINK'} and $do ){
    $re->{'DEL'} = $re->{'TREE'} = $re->{'INF'} = 0;
     $re->{'LIST'} = $re->{'COL'} = 1;
      Fork_1( $re );
   }elsif( $do ){
    $re->{'COL'} = $re->{'TREE'} = $re->{'DEL'} = 2;
     Fork_1( $re );
   }
  }
 }
 exit;
}

sub File_1{
my( $re,$list ) = @_; my( $i,$e,@tap,$file ) = ( -1,0 );
  unless( $re->{'TAP'} ){
   open my $BREW,'<',$re->{'TXT'} or die " File_1 $!\n";
    chomp( @$file=<$BREW> );
   close $BREW;
  }
  $tap[0] = $file if $re->{'CAS'} and defined $re->{'S_OPT'} or $re->{'BL'};
  if( $re->{'CAS'} and -f $re->{'Q_TAP'} ){
   open my $TAP,'<',$re->{'Q_TAP'} or die " File_1 $!\n";
    while(my $tap=<$TAP>){ chomp $tap;
     if( $tap =~ /^[3-9#]$/ ){
       if( $re->{'FDIR'} and $re->{'DDIR'} and $re->{'VERS'} and $tap ne '9' or
           $re->{'FDIR'} and $re->{'DDIR'} and not $re->{'VERS'} and $tap ne '8' or
           $re->{'FDIR'} and $re->{'VERS'} and not $re->{'DDIR'} and $tap ne '7' or
           $re->{'DDIR'} and $re->{'VERS'} and not $re->{'FDIR'} and $tap ne '6' or
           $re->{'FDIR'} and not $re->{'DDIR'} and not $re->{'VERS'} and $tap ne '5' or
           $re->{'DDIR'} and not $re->{'FDIR'} and not $re->{'VERS'} and $tap ne '4' or
           $re->{'VERS'} and not $re->{'FDIR'} and not $re->{'DDIR'} and $tap ne '3' or
           not( $re->{'VERS'} or $re->{'FDIR'} or $re->{'DDIR'} ) and $tap ne '#' ){
            die " exist \033[31mLOCK\033[0m\n" if -d "$re->{'HOME'}/LOCK";
             $SIG{'INT'} = $SIG{'QUIT'} = $SIG{'TERM'} = sub{ my( $not ) = Doc_1; die "\x1B[?25h$not" };
              $re->{'TEN'} = 1;
               select undef,undef,undef,0.1;
                Wait_1( $re );
       }
        last if not $re->{'TAP'} and $re->{'CAS'} and ( $re->{'LIST'} or $re->{'PRINT'} or $re->{'DAT'} );
       exit unless ( not $re->{'TAP'} or $re->{'FDIR'} or $re->{'DDIR'} or $re->{'VERS'} ) and
                   ( not $re->{'PRE'} or $re->{'FDIR'} );
       Prew_1( $re ) if $re->{'PRE'};
      next;
     }
      if( $re->{'TAP'} ){
       $i++ if $tap =~ /^[012]$/;
        push @{$tap[$i]},$tap;
      }elsif( $re->{'BL'} or defined $re->{'S_OPT'} ){
       $e++ if $tap =~ /^[012]$/;
        push @{$tap[$e]},$tap;
      }else{
        push @{$file},$tap;
      }
    }
   close $TAP;
  }elsif( $re->{'TAP'} and not -f $re->{'Q_TAP'} ){
    die " Tap No such file\n";
  }
  if( -d "$ENV{'HOME'}/.JA_BREW" and not $re->{'EN'} and ( $re->{'LIST'} or $re->{'PRINT'} or $re->{'DEP'} ) ){
    no warnings 'closed';
   if( $re->{'FOR'} or $re->{'DEP'} ){
    open my $JA,'<',"$ENV{'HOME'}/.JA_BREW/ja_brew.txt" or print " ### Not exist brew JA_file ###\n";
     while(<$JA>){
     my( $name,$desc ) = split '\t';
      chomp( $JA{$name} = $desc );
     }
    close $JA;
   }
   if( $re->{'CAS'} and ( not $re->{'TAP'} or $re->{'DEP'} ) ){
    open my $JA,'<',"$ENV{'HOME'}/.JA_BREW/ja_cask.txt" or print " ### Not exist cask JA_file ###\n";
     while(<$JA>){
     my( $name,$desc ) = split '\t';
      chomp( $JA{$name} = $desc );
     }
    close $JA;
   }
   if( ( $re->{'FDIR'} or $re->{'DDIR'} or $re->{'VERS'} ) and ( $re->{'CAS'} or $re->{'TAP'} or $re->{'DEP'} ) ){
    open my $JA,'<',"$ENV{'HOME'}/.JA_BREW/ja_tap.txt" or print " ### Not exist tap JA_file ###\n";
     while(<$JA>){
     my( $name,$desc ) = split '\t';
      chomp( $JA{$name} = $desc );
     }
    close $JA;
   }
  }
  Format_3( $file,$re ) if $re->{'DEP'};
   $re->{'AN'} = $re->{'IN'} = $re->{'BN'} = $re->{'CN'} = $re->{'DN'} = $re->{'DI'} = 0;
  if( $re->{'TAP'} ){ my $i = 0; my $e = 0;
   for my $ta1(@tap){
    Search_1( $list,$ta1,0,$re );
     unless( defined $re->{'L_OPT'} ){
      $i = $re->{'AN'} - $i; $e = $re->{'IN'} - $e;
       $re->{'ALL'} .= "$re->{'SPA'} item $i : install $e\n" if $i;
      $i = $re->{'AN'}; $e = $re->{'IN'};
     }elsif( not $re->{'KEN'} ){
      $i = $re->{'BN'} - $i; $e = $re->{'CN'} - $e;
       $re->{'EXC'} .= "$re->{'SPA'} item $i : install $e\n" if $i;
      $i = $re->{'BN'}; $e = $re->{'CN'};
     }else{
      $i = $re->{'DN'} - $i; $e = $re->{'DI'} - $e;
       $re->{'KXC'} .= "$re->{'SPA'} item $i : install $e\n" if $i;
      $i = $re->{'DN'}; $e = $re->{'DI'};
     }
   }
  }elsif( $re->{'CAS'} and defined $re->{'S_OPT'} or $re->{'BL'} ){
   for my $ta2(@tap){ Search_1( $list,$ta2,0,$re ) }
  }else{
   Search_1( $list,$file,0,$re );
  }
}

sub Unic_1{
my( $re,$brew,$spa,$AN,$build ) = @_;
 my $name = $$brew;
  $$brew =  $re->{'OS'}{"$${brew}alia"} ? $re->{'OS'}{"$${brew}alia"} : $$brew;
 $name = -t STDOUT ? "$name \033[33m(require)\033[0m" : "$name (require)"
   if not $re->{'COL'} and ( not $re->{'HASH'}{$$brew} and not $re->{'DMG'}{$$brew} or
          $re->{'HASH'}{$$brew} and Version_1( $re->{'OS'}{"$${brew}ver"},$re->{'HASH'}{$$brew} ) );
 $name = -t STDOUT ? "$name \033[33m(can delete)\033[0m" : "$name (can delete)"
   if $re->{'COL'} and $re->{"$${brew}delet"} and ( $re->{'HASH'}{$$brew} or $re->{'DMG'}{$$brew} );

 unless( $re->{"$${brew}undel"} ){
  $re->{"deps$$brew"} +=
   ( $re->{'TREE'} and $build ) ? push @{$re->{'UNI'}},"${spa}-- $name [build]\n" :
     $re->{'TREE'} ? push @{$re->{'UNI'}},"${spa}-- $name\n" : 1;
  push @$AN,$$brew if ( $re->{'DEL'} or $re->{'deps'} ) and $re->{"deps$$brew"} < 2;
   $re->{"$re->{'INF'}deps"} .= "$$brew\t"
    if $re->{"deps$$brew"} < 2 and not $build and ( $re->{'HASH'}{$$brew} or $re->{'DMG'}{$$brew} );
 }
}

sub Info_1{
my( $re,$file,$spa,$AN ) = @_;
  if( not $file and $re->{'FOR'} and -t STDOUT and
  ( ( $re->{'MAC'} and ( $re->{'OS'}{"$re->{'INF'}un_xcode"} or $re->{'OS'}{"$re->{'INF'}un_cask"} ) ) or
    ( $re->{'LIN'} and $re->{'OS'}{"$re->{'INF'}un_Linux"} ) ) ){
   $re->{'deps'} ? $re->{'NOT'} = " \033[33mCan't install $re->{'INF'}...\033[0m\n":
    print " \033[33mCan't install $re->{'INF'}...\033[0m\n";
  }
 if( not $file and $re->{'FOR'} and -t STDOUT and $re->{'OS'}{"$re->{'INF'}so_name"} and not $re->{'DEL'} ){
   $re->{'deps'} ? $re->{'NOT'} = " \033[33mexists Formula and Cask $re->{'INF'}...\033[0m\n" :
    print " \033[33mexists Formula and Cask $re->{'INF'}...\033[0m\n";
 }
 my $brew = $file || $re->{'INF'} || exit;
  $re->{'NEW'}++, Init_1( $re ) unless $brew;
   my $bottle =  $re->{'OS'}{"$brew$OS_Version"} ? 1 : 0;
    $spa .= $spa ? '   |' : '|';

 unless( $re->{"${brew}undel"} ){
  if( $re->{'OS'}{"${brew}deps_b"} ){
   for my $data(split '\t',$re->{'OS'}{"${brew}deps_b"}){
    if( not $re->{'OS'}{"${data}so_name"} and ( not $bottle and not $re->{'HASH'}{$brew} or
        not $bottle and Version_1( $re->{'OS'}{"${brew}ver"},$re->{'HASH'}{$brew} ) ) and
      ( not $re->{'HASH'}{$data} or Version_1( $re->{'OS'}{"${data}ver"},$re->{'HASH'}{$data} ) ) ){
        Unic_1( $re,\$data,$spa,$AN,1 );
         Info_1( $re,$data,$spa,$AN );
    }
   }
  }
  if( $re->{'FOR'} and $re->{'OS'}{"${brew}deps"} ){
   for my $data2(split '\t',$re->{'OS'}{"${brew}deps"}){
     Unic_1( $re,\$data2,$spa,$AN );
      Info_1( $re,$data2,$spa,$AN );
   }
  }
  if( $re->{'FOR'} and $re->{'OS'}{"${brew}formula"} ){
   for my $data3(split '\t',$re->{'OS'}{"${brew}formula"}){
     Unic_1( $re,\$data3,$spa,$AN );
      Info_1( $re,$data3,$spa,$AN );
   }
  }
  if( $re->{'OS'}{"${brew}d_cask"} ){
   for my $data4(split '\t',$re->{'OS'}{"${brew}d_cask"}){
    unless( $re->{'FOR'} and $re->{'OS'}{"${data4}so_name"} and not $re->{'TREE'} ){
     Unic_1( $re,\$data4,$spa,$AN );
      Info_1( $re,$data4,$spa,$AN ) unless $re->{'OS'}{"${data4}so_name"};
    }
   }
  }
 }
}

sub Mine_1{
my( $name,$re,$ls ) = @_;
 $name = "$name (I)" if( $ls and -t STDOUT );
 if( $name !~ m|^ ==> homebrew/| ){
  $re->{'LEN'}{$name} = length $name;
   push @{$re->{'ARR'}},$name;
 }else{
   push @{$re->{'ARR'}},$name;
    ( $re->{'BR'} ) = $name =~ m|==>.+/(.+)|; return;
 }
 if( $name =~ m|^homebrew/cask-versions/| ){
   $re->{'LEN4'} = $re->{'LEN'}{$name} if $re->{'LEN4'} < $re->{'LEN'}{$name};
 }elsif( $name =~ m|^homebrew/cask-drivers/| ){
   $re->{'LEN3'} = $re->{'LEN'}{$name} if $re->{'LEN3'} < $re->{'LEN'}{$name};
 }elsif( $name =~ m|^homebrew/cask-fonts/| ){
   $re->{'LEN2'} = $re->{'LEN'}{$name} if $re->{'LEN2'} < $re->{'LEN'}{$name};
 }else{
  if( $re->{'BR'} and $re->{'BR'} eq 'cask-versions' ){
   $re->{'LEN4'} = $re->{'LEN'}{$name} if $re->{'LEN4'} < $re->{'LEN'}{$name};
  }elsif( $re->{'BR'} and $re->{'BR'} eq 'cask-drivers' ){
   $re->{'LEN3'} = $re->{'LEN'}{$name} if $re->{'LEN3'} < $re->{'LEN'}{$name};
  }elsif( $re->{'BR'} and $re->{'BR'} eq 'cask-fonts' ){
   $re->{'LEN2'} = $re->{'LEN'}{$name} if $re->{'LEN2'} < $re->{'LEN'}{$name};
  }else{ $re->{'LEN1'} = $re->{'LEN'}{$name} if $re->{'LEN1'} < $re->{'LEN'}{$name};
  }
 }
}

sub Memo_1{
my( $re,$mem,$dir ) = @_;
 if( defined $dir ){
  my $file = Dirs_1( "$re->{'CEL'}/$dir",2 );
  if( @$file ){
     unless( defined $re->{'L_OPT'} ){ $re->{'ALL'} .= "     Check folder $re->{'CEL'} => $dir\n";
     }elsif( $re->{'KEN'} ){ $re->{'KXC'} .= "     Check folder $re->{'CEL'} => $dir\n";
     }elsif( $mem ){ $re->{'EXC'} .= "     Check folder $re->{'CEL'} => $dir\n";
     }
   for(my $i=0;$i<@$file;$i++){
     unless( defined $re->{'L_OPT'} ){ $re->{'ALL'} .= $#$file == $i ? "    $$file[$i]\n" : "     $$file[$i]";
     }elsif( $re->{'KEN'} ){ $re->{'KXC'} .= $#$file == $i ? "    $$file[$i]\n" : "     $$file[$i]";
     }elsif( $mem ){ $re->{'EXC'} .= $#$file == $i ? "    $$file[$i]\n" : "     $$file[$i]";
     }
   }
  }else{
     unless( defined $re->{'L_OPT'} ){ $re->{'ALL'} .= "     Empty folder $re->{'CEL'} => $dir\n";
     }elsif( $re->{'KEN'} ){ $re->{'KXC'} .= "     Empty folder $re->{'CEL'} => $dir\n";
     }elsif( $mem ){ $re->{'EXC'} .= "     Empty folder $re->{'CEL'} => $dir\n";
     }
  }
 }else{
    $re->{'ALL'} .= $re->{'MEM'} unless defined $re->{'L_OPT'};
     if( $re->{'KEN'} and defined $re->{'L_OPT'} ){
      my( $top,$mee ) = $re->{'MEM'} =~ /^(.{9})(.+)/;
      my( $brew ) = split '\t',$mee;
      my $name = -d "$ENV{'HOME'}/.JA_BREW" ? encode 'utf-8',$re->{'L_OPT'} : $re->{'L_OPT'};
       if( $mee =~ /^ ==>/ or $mee =~ s/(\Q$name\E)/\033[33m$1\033[0m/ig ){
           $mee =~ s/\033\[33m|\033\[00m//g unless -t STDOUT;
          $re->{'DI'}++ if $re->{'HASH'}{$brew} or $re->{'DMG'}{$brew};
         $re->{'DN'}++ if $mee !~ /^ ==>/;
        $re->{'KXC'} .= "$top$mee\n";
       }
     }else{
      $re->{'EXC'} .= $re->{'MEM'} if $mem;
     }
 }
}

sub Version_1{
 my @ls1 = split '\.|-|_',$_[0];
 my @ls2 = split '\.|-|_',$_[1];
 my $i = 0;
  for(;$i<@ls2;$i++){
   if( $ls1[$i] and $ls2[$i] =~ /[^\d]/ ){
     if( $ls1[$i] gt $ls2[$i] ){ return 1;
     }elsif( $ls1[$i] lt $ls2[$i] ){ return;
     }
   }else{
     if( $ls1[$i] and $ls1[$i] > $ls2[$i] ){ return 1;
     }elsif( $ls1[$i] and $ls1[$i] < $ls2[$i] ){ return;
     }
   }
  }
 $ls1[$i] ? 1 : 0;
}

sub Version_2{
my( $re,$ls1,$ls2 ) = @_;
 $re->{'TAR'} = ( $re->{'MAC'} and $re->{'FOR'} ) ?
  Dirs_1( "$ENV{'HOME'}/Library/Caches/Homebrew",2 ) : ( $re->{'MAC'} and $re->{'CAS'} ) ?
   Dirs_1( "$ENV{'HOME'}/Library/Caches/Homebrew/Cask",2 ) :
    Dirs_1( "$ENV{'HOME'}/.cache/Homebrew",2 ) unless $re->{'TAR'};
 for my $gz( @{$re->{'TAR'}} ){
  if( $gz =~ s/^$ls1--([\d._-]+)\.[^\d_-]+\d?$/$1/ or $gz =~ s/^$ls1--([\d._-]+)$/$1/ ){
    $re->{'GZ'} = ( $re->{'FOR'} and Version_1($gz,$re->{'HASH'}{$ls1}) ) ? 1 :
                  ( $re->{'CAS'} and Version_1($gz,$re->{'DMG'}{$ls1}) )  ? 1 : 0;
    last if $re->{'GZ'};
   }
 }
  $re->{'GZ'} ? Type_1( $re,$ls1,'(i)','e' ) : Type_1( $re,$ls1,'(i)' );
   if( -t STDOUT ){
    $re->{'OUT'}[$re->{'UP'}++] = ( $re->{'FOR'} and $re->{'GZ'} ) ?
     " e $ls1 $re->{'HASH'}{$ls1} < $ls2\n" : ( $re->{'CAS'} and $re->{'GZ'} ) ?
     " e $ls1 $re->{'DMG'}{$ls1} != $ls2 : Cask\n"  : $re->{'FOR'} ?
     "   $ls1 $re->{'HASH'}{$ls1} < $ls2\n" : "   $ls1 $re->{'DMG'}{$ls1} != $ls2 : Cask\n";
   }else{
    $re->{'OUT'}[$re->{'UP'}++] = "$ls1\n" unless $re->{'GZ'};
   }
  $re->{'GZ'} = 0;
}

sub Search_1{ no warnings 'regexp';
my( $list,$file,$in,$re ) = @_;
 for(my $i=0;$i<@$file;$i++){ my $pop = 0;
  my( $brew_1,$brew_2,$brew_3 ) = split '\t',$file->[$i];
   next if not defined $re->{'S_OPT'} and $brew_1 =~ m|^homebrew/|;
    my $mem = ( defined $re->{'L_OPT'} and ( $brew_1 =~ /$re->{'L_OPT'}/ or $brew_1 =~ /^[012]$/ ) ) ? 1 : 0;

  $brew_1 = $brew_1 eq '0' ? ' ==> homebrew/cask-fonts' :
            $brew_1 eq '1' ? ' ==> homebrew/cask-drivers' :
            $brew_1 eq '2' ? ' ==> homebrew/cask-versions' : $brew_1;
  Mine_1($brew_1,$re,0), next if ( $re->{'BL'} or defined $re->{'S_OPT'} ) and $brew_1 =~ m|^ ==> homebrew/|;

  $brew_2 = $re->{'OS'}{"${brew_1}c_version"} if $re->{'TAP'} or $re->{'CAS'} and
            $re->{'OS'}{"${brew_1}c_version"} and length $re->{'OS'}{"${brew_1}c_version"} <= length $brew_2;
  $brew_2 = $re->{'OS'}{"${brew_1}ver"} ? $re->{'OS'}{"${brew_1}ver"} : $brew_2 if $re->{'FOR'};

  $brew_3 = ( $re->{'CAS'} and $re->{'OS'}{"${brew_1}c_desc"} ) ? $re->{'OS'}{"${brew_1}c_desc"} :
   ( $re->{'TAP'} and $re->{'OS'}{"${brew_1}c_name"} ) ? $re->{'OS'}{"${brew_1}c_name"} : $brew_3 ? $brew_3 : 0;
    $brew_3 = $JA{$brew_1} if $JA{$brew_1};
     $brew_3 =~ s/[“”]//g unless $Locale;

  if( not $re->{'LINK'} or
      $re->{'LINK'} == 1 and $re->{'OS'}{"${brew_1}un_xcode"} or
      $re->{'LINK'} == 2 and $re->{'OS'}{"${brew_1}un_Linux"} or
      $re->{'LINK'} == 3 and $re->{'OS'}{"$brew_1$OS_Version"} or
      $re->{'LINK'} == 4 and $re->{'OS'}{"${brew_1}un_cask"} or
      $re->{'LINK'} == 5 and $re->{'OS'}{"${brew_1}so_name"} or
      $re->{'LINK'} == 6 and $re->{"deps$brew_1"} or
      $re->{'LINK'} == 7 and $re->{"${brew_1}delet"} or
      $re->{'LINK'} == 8 and $re->{'OS'}{"${brew_1}font"} ){

    if( $list->[$in] and " $brew_1\n" gt $list->[$in] ){
     Tap_1( $list,$re,\$in );
      $i--; next;
    }elsif( $list->[$in] and " $brew_1\n" eq $list->[$in] ){
     if( defined $re->{'S_OPT'} ){ my $ls = $brew_1;
      Tap_2( $re,\$ls ) if $re->{'FOR'};
      ( $re->{'DMG'}{$brew_1} or $re->{'HASH'}{$brew_1} ) ?
       Mine_1( $ls,$re,1 ) : Mine_1( $ls,$re,0 ) if $brew_1 =~ /$re->{'S_OPT'}/o;
     }elsif( $re->{'BL'} and $re->{'DMG'}{$brew_1} ){ Mine_1( $brew_1,$re,0 );
     } $pop = ++$in;
        $re->{'IN'}++; $re->{'CN'}++ if $mem;
    }else{
     if( defined $re->{'S_OPT'} and $brew_1 =~ m|(?!.*/)$re->{'S_OPT'}|o ){
      if( my( $opt ) = $brew_1 =~ m|^homebrew/.+/(.+)| ){
       Mine_1( $brew_1,$re,0 ) if $opt =~ /\b$re->{'S_OPT'}\b/o and $re->{'S_OPT'} !~ /^(-|\\-)$/;
      }else{ Mine_1( $brew_1,$re,0 ); }
     }
    }
   unless( defined $re->{'S_OPT'} or $re->{'BL'} ){
     if( $re->{'MAC'} ){
      if( $re->{'FOR'} ){
       $re->{'MEM'} = ( $re->{'OS'}{"$brew_1$OS_Version"} and $re->{'OS'}{"${brew_1}keg"} ) ?
        " b k     $brew_1\t" : $re->{'OS'}{"$brew_1$OS_Version"} ? " b       $brew_1\t" :
         ( $re->{'OS'}{"${brew_1}un_xcode"} and $re->{'OS'}{"${brew_1}keg"} ) ?
       " x k     $brew_1\t" : $re->{'OS'}{"${brew_1}un_xcode"} ? " x       $brew_1\t" :
       $re->{'OS'}{"${brew_1}keg"} ? "   k     $brew_1\t" : "$re->{'SPA'}$brew_1\t";
      }else{
       $re->{'MEM'} = ( $re->{'OS'}{"${brew_1}un_cask"} and $re->{'OS'}{"${brew_1}so_name"} ) ?
        " x s     $brew_1\t" : ( $re->{'OS'}{"${brew_1}un_cask"} and $re->{'OS'}{"${brew_1}d_cask"} ) ?
        " x c     $brew_1\t" : ( $re->{'OS'}{"${brew_1}un_cask"} and $re->{'OS'}{"${brew_1}formula"} ) ?
        " x f     $brew_1\t" : $re->{'OS'}{"${brew_1}un_cask"} ? " x       $brew_1\t" :
       $re->{'OS'}{"${brew_1}so_name"} ? "   s     $brew_1\t" : $re->{'OS'}{"${brew_1}d_cask"} ?
        "   c     $brew_1\t" : $re->{'OS'}{"${brew_1}formula"} ?
        "   f     $brew_1\t" : $re->{'OS'}{"${brew_1}font"} ?
        "   p     $brew_1\t" : "$re->{'SPA'}$brew_1\t";
      }
     }else{
       $re->{'MEM'} = ( $re->{'OS'}{"$brew_1$OS_Version"} and $re->{'OS'}{"${brew_1}keg_Linux"} ) ?
       " b k     $brew_1\t" : $re->{'OS'}{"$brew_1$OS_Version"} ? " b       $brew_1\t" :
        ( $re->{'OS'}{"${brew_1}un_Linux"} and $re->{'OS'}{"${brew_1}keg_Linux"} ) ?
       " x k     $brew_1\t" : $re->{'OS'}{"${brew_1}un_Linux"}  ? " x       $brew_1\t" :
       $re->{'OS'}{"${brew_1}keg_Linux"} ? "   k     $brew_1\t" : "$re->{'SPA'}$brew_1\t";
     }
    if( $pop ){
     if( not $list->[$in] or $list->[$in] =~ /^\s/ ){
       Memo_1( $re,$mem,$brew_1 );
         $i--; next;
     }elsif( $list->[$in + 1] and $list->[$in + 1] !~ /^\s/ ){
       Memo_1( $re,$mem,$brew_1 );
       while(1){ $in++;
        last if not $list->[$in + 1] or $list->[$in + 1] =~ /^\s/;
       }
     }
     if( $re->{'FOR'} and not $re->{'HASH'}{$brew_1} or
         $re->{'CAS'} and not $re->{'DMG'}{$brew_1} ){
           $re->{'MEM'} =~ s/^.{9}$brew_1\t/      X  $brew_1\tNot Formula\n/;
            Memo_1( $re,$mem );
             $in++; $i--; next;
     }else{
      if( $re->{'FOR'} and Version_1( $brew_2,$re->{'HASH'}{$brew_1} ) and
         not( $re->{'OS'}{"${brew_1}un_xcode"} and $re->{'OS'}{"${brew_1}un_Linux"} ) or
          $re->{'CAS'} and not $re->{'OS'}{"${brew_1}un_cask"} and $brew_2 ne $re->{'DMG'}{$brew_1} ){
         Version_2( $re,$brew_1,$brew_2 );
      }else{
         Type_1( $re,$brew_1,' i ' );
      }
     }
     $in++;
    }
    $re->{'MEM'} .= "$brew_2\t$brew_3\n" if defined $brew_2;
     $re->{'MEM'} =~ s/\t/\n/ unless defined $brew_2;
      Memo_1( $re,$mem ) if $re->{'LIST'} or $pop;
       $re->{'BN'}++ if $mem and $brew_1 !~ m|==> homebrew/|;
        $re->{'AN'}++ if $brew_1 !~ m|==> homebrew/|;
   }
  }
 }
 if( $list->[$in] ){
  Tap_1( $list,$re,\$in ) while($list->[$in]);
 }
 unless( $re->{'LIST'} ){ my @tap = ([],[],[]);
  for my $arr(@{$re->{'ARY'}}){
   push @{$tap[2]},$arr if $arr =~ s/^homebrew-cask-versions\n(.+)/$1/;
    push @{$tap[1]},$arr if $arr =~ s/^homebrew-cask-drivers\n(.+)/$1/;
     push @{$tap[0]},$arr if $arr =~ s/^homebrew-cask-fonts\n(.+)/$1/;
  } my( $i,$flag1,$flag2 ); my $e = 0;
  for my $tap( @tap ){ $i++;
   $flag2++, $re->{'ALL'} .= "$re->{'SPA'} in_item $re->{'IN'}\n" if @$tap and $re->{'ALL'} and not $flag2;
   $i++ unless @$tap;
   for my $ta1(@$tap){
    if( $i == 1 ){ $i++;
      $re->{'ALL'} .= "$re->{'SPA'} ==> homebrew/cask-fonts\n";
    }elsif( $i == 3 ){ $i++;
      $re->{'ALL'} .= "$re->{'SPA'} in_item $e\n" if $e; $e = 0;
      $re->{'ALL'} .= "$re->{'SPA'} ==> homebrew/cask-drivers\n";
    }elsif( $i == 5 ){ $i++;
      $re->{'ALL'} .= "$re->{'SPA'} in_item $e\n" if $e; $e = 0;
      $re->{'ALL'} .= "$re->{'SPA'} ==> homebrew/cask-versions\n";
    }
    if( $i == 2 ){ $e++;
    }elsif( $i == 4 ){ $e++;
    }elsif( $i == 6 ){ $e++; $flag1 = 1;
    } $re->{'ALL'} .= $ta1;
     $re->{'AN'}++; $re->{'IN'}++;
   }
  } $re->{'ALL'} .= "$re->{'SPA'} in_item $e\n" if $flag1;
 }
}

sub Tap_1{ no warnings 'regexp';
my( $list,$re,$in ) = @_;
 unless( $re->{'CAS'} and defined $re->{'S_OPT'} or $re->{'BL'} ){
  my( $tap ) = $list->[$$in] =~ /^\s(.*)\n/;
   my $mem = ( defined $re->{'L_OPT'} and $tap =~ /$re->{'L_OPT'}/ ) ? 1 : 0;
    my( $dirs1 ) = $re->{'OS'}{"${tap}cask"} =~ m|.+/(homebrew-[^/]+)/.+|
    if not $re->{'FOR'} and $re->{'OS'}{"${tap}cask"};

    my $ver = ( $re->{'FOR'} and $re->{'OS'}{"${tap}f_version"}) ?
     $re->{'OS'}{"${tap}f_version"} : ( $re->{'CAS'} and $re->{'OS'}{"${tap}c_version"}) ?
      $re->{'OS'}{"${tap}c_version"} : ( $re->{'FOR'} and $re->{'HASH'}{$tap} ) ?
       $re->{'HASH'}{$tap} : ( $re->{'CAS'} and $re->{'DMG'}{$tap} ) ? $re->{'DMG'}{$tap} : 0;
    $ver = $ver.$re->{'OS'}{"${tap}revision"}
     if $re->{'FOR'} and $ver !~ /_\d+$/ and $re->{'OS'}{"${tap}revision"};

    my $com = ( $re->{'FOR'} and $re->{'OS'}{"${tap}f_desc"} ) ?
     $re->{'OS'}{"${tap}f_desc"} : ( $re->{'FOR'} and $re->{'OS'}{"${tap}f_name"} ) ?
      $re->{'OS'}{"${tap}f_name"} : ( $re->{'CAS'} and $re->{'OS'}{"${tap}c_desc"} ) ?
       $re->{'OS'}{"${tap}c_desc"} : ( $re->{'CAS'} and $re->{'OS'}{"${tap}c_name"} ) ?
        $re->{'OS'}{"${tap}c_name"} : 0;
     $com = $JA{$tap} if $JA{$tap};

      my $brew = 1;
   if( $re->{'LINK'} and $re->{'LINK'} == 1 and not $re->{'OS'}{"${tap}un_xcode"} or
       $re->{'LINK'} and $re->{'LINK'} == 2 and not $re->{'OS'}{"${tap}un_Linux"} or
       $re->{'LINK'} and $re->{'LINK'} == 3 and not $re->{'OS'}{"$tap$OS_Version"} or
       $re->{'LINK'} and $re->{'LINK'} == 4 and not $re->{'OS'}{"${tap}un_cask"} or
       $re->{'LINK'} and $re->{'LINK'} == 5 and not $re->{'OS'}{"${tap}so_name"} or
       $re->{'LINK'} and $re->{'LINK'} == 6 and not $re->{"deps$tap"} or
       $re->{'LINK'} and $re->{'LINK'} == 7 and not $re->{"${tap}delet"} or
       $re->{'LINK'} and $re->{'LINK'} == 8 and not $re->{'OS'}{"${tap}font"} ){
      $brew = 0;
   }
  if( defined $re->{'S_OPT'} and $tap =~ /$re->{'S_OPT'}/ and ( $re->{'DMG'}{$tap} or $re->{'HASH'}{$tap} ) ){
       Tap_2( $re,\$tap ) if $re->{'FOR'};
        Mine_1( $tap,$re,1 );
  }elsif( $list->[$$in + 1] and $list->[$$in + 1] !~ /^\s/ ){ $$in++;
    if( $list->[$$in + 1] and $list->[$$in + 1] !~ /^\s/ ){
     Memo_1( $re,$mem,$tap );
      while(1){ $$in++;
       last if not $list->[$$in + 1] or $list->[$$in + 1] =~ /^\s/;
      }
    }
    if( $re->{'FOR'} and not $re->{'HASH'}{$tap} or
        $re->{'CAS'} and not $re->{'DMG'}{$tap} ){
        $re->{'MEM'} = "      X  $tap\tNot Formula\n";
         Memo_1( $re,$mem ) unless $re->{'FOR'};
    }elsif( $re->{'FOR'} and Version_1( $ver,$re->{'HASH'}{$tap} ) and
           not( $re->{'OS'}{"${tap}un_xcode"} and $re->{'OS'}{"${tap}un_Linux"} ) or
            $re->{'CAS'} and not $re->{'OS'}{"${tap}un_cask"} and $ver ne $re->{'DMG'}{$tap} ){
        $re->{'MEM'} = "$re->{'SPA'}$tap\t$ver\t$com\n";
         Version_2( $re,$tap,$ver );
    }else{
        $re->{'MEM'} = "$re->{'SPA'}$tap\t$ver\t$com\n";
         Type_1( $re,$tap,' i ' );
    }
       push @{$re->{'ARY'}},"$dirs1\n".$re->{'MEM'} if $dirs1;
     if( $brew and not @{$re->{'ARY'}} ){
      Memo_1( $re,$mem );
       $re->{'AN'}++; $re->{'IN'}++;
      $re->{'BN'}++, $re->{'CN'}++ if $mem;
     }
  }else{
    Memo_1( $re,$mem,$tap );
  }
 }
 $$in++;
}

sub Tap_2{
my( $re,$tap ) = @_;
 Tap_3( $re->{'TAP_S'},$re ) unless $re->{'TAP2'};
  m|/$$tap| ? $$tap = $_ : 0 for @{$re->{'TAP2'}};
}

sub Tap_3{
my( $dir,$re ) = @_;
 for my $ls(glob "$dir/*"){
  next if $ls =~ m|/homebrew$|;
   Tap_3( $ls,$re ) if -d $ls;
  push @{$re->{'TAP2'}},$ls if $ls =~ s|.+/Taps/([^/]+)/homebrew-([^/]+)/(?:[^/]+/)*([^/]+)\.rb$|$1/$2/$3|;
 }
}

sub Type_1{
my( $re,$brew_1,$i,$e ) = @_;
 if( $re->{'MAC'} ){
  if( $re->{'FOR'} ){
   ( $re->{'OS'}{"${brew_1}un_xcode"} and $re->{'OS'}{"${brew_1}keg"} ) ?
    $re->{'MEM'} =~ s/^.{9}/ t k $i / : $re->{'OS'}{"${brew_1}un_xcode"} ?
    $re->{'MEM'} =~ s/^.{9}/ t   $i / :
   ( $re->{'OS'}{"$brew_1$OS_Version"} and $re->{'OS'}{"${brew_1}keg"} ) ?
    $re->{'MEM'} =~ s/^.{9}/ b k $i / : ( $e and $re->{'OS'}{"${brew_1}keg"} ) ?
    $re->{'MEM'} =~ s/^.{9}/ e k $i / :  $re->{'OS'}{"$brew_1$OS_Version"} ?
    $re->{'MEM'} =~ s/^.{9}/ b   $i / : $re->{'OS'}{"${brew_1}keg"} ?
    $re->{'MEM'} =~ s/^.{9}/   k $i / : $e ? $re->{'MEM'} =~ s/^.{9}/ e   $i / :
    $re->{'MEM'} =~ s/^.{9}/     $i /;
  }else{
   ( $re->{'OS'}{"${brew_1}un_cask"} and  $re->{'OS'}{"${brew_1}so_name"} ) ?
    $re->{'MEM'} =~ s/^.{9}/ t s $i / :
   ( $re->{'OS'}{"${brew_1}un_cask"} and  $re->{'OS'}{"${brew_1}formula"} ) ?
    $re->{'MEM'} =~ s/^.{9}/ t f $i / :
   ( $re->{'OS'}{"${brew_1}un_cask"} and  $re->{'OS'}{"${brew_1}d_cask"} ) ?
    $re->{'MEM'} =~ s/^.{9}/ t c $i / : $re->{'OS'}{"${brew_1}un_cask"} ?
    $re->{'MEM'} =~ s/^.{9}/ t   $i / : $re->{'OS'}{"${brew_1}so_name"} ?
    $re->{'MEM'} =~ s/^.{9}/   s $i / : $re->{'OS'}{"${brew_1}formula"} ?
    $re->{'MEM'} =~ s/^.{9}/   f $i / : $re->{'OS'}{"${brew_1}d_cask"} ?
    $re->{'MEM'} =~ s/^.{9}/   c $i / : $re->{'OS'}{"${brew_1}font"} ?
    $re->{'MEM'} =~ s/^.{9}/   p $i / : $re->{'MEM'} =~ s/^.{9}/     $i /;
  }
 }else{
  ( $re->{'OS'}{"$brew_1$OS_Version"} and $re->{'OS'}{"${brew_1}keg_Linux"} ) ?
   $re->{'MEM'} =~ s/^.{9}/ b k $i / : $re->{'OS'}{"$brew_1$OS_Version"} ?
   $re->{'MEM'} =~ s/^.{9}/ b   $i / : $re->{'OS'}{"${brew_1}keg_Linux"} ?
   $re->{'MEM'} =~ s/^.{9}/   k $i / : $re->{'MEM'} =~ s/^.{9}/     $i /;
 }
}

sub Command_1{
my $re = shift; my( $ls1,$ls2,%HA,%OP );
 Like_1( $re,[\$re->{'STDI'}],1 );
 exit unless my $num = $re->{'HASH'}{$re->{'STDI'}};
 $re->{'CELD'} = "$re->{'CEL'}/\Q$re->{'STDI'}\E/$num";
  for $ls1(`find $re->{'CEL'}/$re->{'STDI'}/$num -type f`){ chomp $ls1;
   next if $ls1 =~ m[^$re->{'CELD'}/[^.][^/]+$|^$re->{'CELD'}/\.brew]o;
   if( $ls1 =~ m[^$re->{'CELD'}/\.|^$re->{'CELD'}/s?bin/]o ){
           print"$ls1\n";
   }elsif(not -l $ls1 and $ls1 =~ m|^$re->{'CELD'}/lib/[^/]+dylib$|o){
           print"$ls1\n"; $re->{'INN'} = 1;
   }else{ $ls2 = $ls1;
     $ls1 =~ s|^($re->{'CELD'}/[^/]+/[^/]+)/.+(/.+)|$1$2|o;
       $HA{$ls1}++ if $ls1 =~ s|(.+)/.+|$1|;
     $ls2 =~ s|^$re->{'CELD'}/[^/]+/[^/]+/(.+)|$1|o;
       $OP{$ls1} = $ls2;
   }
  }
  for my $key(sort keys %HA){
   if( $HA{$key} == 1 ){
     $OP{$key} =~ /^$re->{'CELD'}/o ? print"$OP{$key}\n" : print"$key/$OP{$key}\n";
   }else{
     ( $re->{'INN'} and  $key =~ m|^$re->{'CELD'}/lib$|o ) ?
     print"$key/ ($HA{$key} other file)\n" : print"$key/ ($HA{$key} file)\n";
   }
  }
 Nohup_1( $re );
}

sub Format_1{
 my $re = shift;
 if( $re->{'TREE'} and not $re->{'LIKE'} ){ Format_2( $re );
 }elsif( $re->{'LIST'} or $re->{'PRINT'} ){
  waitpid $re->{'PID2'},0 if $re->{'LINK'} and $re->{'LINK'} == 7 and rmdir "$re->{'HOME'}/WAIT";
  $re->{'ZEN'} = $re->{'ALL'} || $re->{'EXC'} || $re->{'KXC'} || 0;
  if( $re->{'CAS'} ){
    $re->{'ZEN'} = $re->{'ZEN'} =~ /^\s{10}==>.*\n\s{10}==>.*\n\s{10}==>.*\n$/ ? 0 :
    $re->{'ZEN'} =~ /^(\s{10}==>.*\n)([^=]+)(\s{10}==>.*\n)([^=]+)\s{10}==> .*\n$/ ? "$1$2$3$4" :
    $re->{'ZEN'} =~ /^(\s{10}==>.*\n)([^=]+)\s{10}==>.*\n(\s{10}==> .*\n)([^=]+)$/ ? "$1$2$3$4" :
    $re->{'ZEN'} =~ /^\s{10}==>.*\n(\s{10}==>.*\n)([^=]+)(\s{10}==> .*\n)([^=]+)$/ ? "$1$2$3$4" :
    $re->{'ZEN'} =~ /^(\s{10}==>.*\n)([^=]+)\s{10}==>.*\n\s{10}==> .*\n$/ ? "$1$2" :
    $re->{'ZEN'} =~ /^\s{10}==>.*\n(\s{10}==>.*\n)([^=]+)\s{10}==> .*\n$/ ? "$1$2" :
    $re->{'ZEN'} =~ /^\s{10}==>.*\n\s{10}==>.*\n(\s{10}==> .*\n)([^=]+)$/ ? "$1$2" :
    $re->{'ZEN'} =~ /^\s{10}==>.*\n(\s{10}==> .*\n)([^=]+)$/ ? "$1$2" :
    $re->{'ZEN'} =~ /^(\s{10}==> .*\n)([^=]+)\s{10}==>.*\n$/ ? "$1$2" :
    $re->{'ZEN'} =~ /^\s{10}==>.*\n\s{10}==>.*\n$/ ? 0 :
    $re->{'ZEN'} =~ /^\s{10}==>.*\n$/ ? 0 :
    $re->{'ZEN'} if $re->{'TAP'} and ( $re->{'EXC'} or $re->{'KXC'} );
   $re->{'ZEN'} =~ s/(.+)\n\s{10}item.+:.+/$1/
    if $re->{'ZEN'} !~ /item.+:\sinstall[^:]+item.+:\sinstall/;
  }
  if( $re->{'ZEN'} ){
   system " printf '\033[?7l' " if( $re->{'MAC'} and -t STDOUT );
    system 'setterm -linewrap off' if( $re->{'LIN'} and -t STDOUT );
     ( $re->{'LINK'} > 5 and $re->{'FOR'} ) ? print" ==> Formula\n" :
     ( $re->{'LINK'} > 5 and $re->{'LINK'} < 8 and $re->{'CAS'} ) ? print" ==> Casks\n" : 0 if $re->{'LINK'};
     print $re->{'ZEN'};
     $re->{'ALL'} ? print " item $re->{'AN'} : install $re->{'IN'}\n" :
     $re->{'EXC'} ? print " item $re->{'BN'} : install $re->{'CN'}\n" :
     $re->{'KXC'} ? print " item $re->{'DN'} : install $re->{'DI'}\n" : 0;
   system " printf '\033[?7h' " if( $re->{'MAC'} and -t STDOUT );
    system 'setterm -linewrap on' if( $re->{'LIN'} and -t STDOUT );
  }
  $re->{'FOR'} = 0 if $re->{'LINK'} and $re->{'LINK'} > 5;
 }elsif( $re->{'DAT'} ){
  print for @{$re->{'OUT'}};
   $re->{'FOR'} = 0;
 }else{
  if( -t STDOUT ){ my( $ls,$sl,$ss,$ze );
   my $leng = $re->{'LEN1'};
    $re->{'TPUT'} = `tput cols` unless $re->{'TPUT'};
     my $size = ( $re->{'TPUT'}/($leng+2) ) >> 0;
      my $in = 1;
      $re->{'PRE'} ? print" ==> Fonts\n" :
    ( $re->{'FOR'} and ( $re->{'BL'} or defined $re->{'S_OPT'} or $re->{'TOP'} ) ) ? print" ==> Formula\n" :
    ( $re->{'CAS'} and $re->{'ARR'}[0] !~ m|homebrew/| ) ? print" ==> Casks\n" : 0 if @{$re->{'ARR'}};
     for(my $e=0;$e<@{$re->{'ARR'}};$e++ ){
      if( $re->{'ARR'}[$e] =~ /^ ==> Formula|^ ==> Cask/ ){
       ( not $re->{'KAI'} and $re->{'ARR'}[$e] =~ /^ ==> Cask/ ) ?
        print"\n$re->{'ARR'}[$e]\n" : print"$re->{'ARR'}[$e]\n"; $in = 1;
      }else{
       if( $re->{'ARR'}[$e] =~ m|homebrew/cask-fonts| and not $ls ){
        next if $re->{'ARR'}[$e] =~ /^ ==>/ and ( not $re->{'ARR'}[$e+1] or $re->{'ARR'}[$e+1] =~ /^ ==>/ );
         print"\n" if $ze;
          $leng = $re->{'LEN2'};
           $size = ( $re->{'TPUT'}/($leng+2) ) >> 0;  $in = $ls = 1;
        if( $re->{'ARR'}[$e] =~ /^ ==>/ and $re->{'ARR'}[$e+1] ){ print"$re->{'ARR'}[$e]\n"; next;
        }else{ print" ==> brew tap : homebrew/cask-fonts\n"; }
       }elsif( $re->{'ARR'}[$e] =~ m|homebrew/cask-drivers| and not $sl ){
        next if $re->{'ARR'}[$e] =~ /^ ==>/ and ( not $re->{'ARR'}[$e+1] or $re->{'ARR'}[$e+1] =~ /^ ==>/ );
         print"\n" if $ze;
          $leng = $re->{'LEN3'};
           $size = ( $re->{'TPUT'}/($leng+2) ) >> 0;  $in = $sl = 1;
        if( $re->{'ARR'}[$e] =~ /^ ==>/ ){ print"$re->{'ARR'}[$e]\n"; next;
        }else{ print" ==> brew tap : homebrew/cask-drivers\n"; }
       }elsif( $re->{'ARR'}[$e] =~ m|homebrew/cask-versions| and not $ss ){
        next if $re->{'ARR'}[$e] =~ /^ ==>/ and ( not $re->{'ARR'}[$e+1] or $re->{'ARR'}[$e+1] =~ /^ ==>/ );
         print"\n" if $ze;
          $leng = $re->{'LEN4'};
           $size = ( $re->{'TPUT'}/($leng+2) ) >> 0;  $in = $ss = 1;
        if( $re->{'ARR'}[$e] =~ /^ ==>/ ){ print"$re->{'ARR'}[$e]\n"; next;
        }else{ print" ==> brew tap : homebrew/cask-versions\n"; }
       }
       for(my $i=$re->{'LEN'}{$re->{'ARR'}[$e]};$i<$leng+2;$i++){
        $re->{'ARR'}[$e] .= ' ';
       }
        print $re->{'ARR'}[$e];
         if( $re->{'deps'} and not $re->{'dep_s'} ){
          my $leng1 = $leng * ( ( $size and $in % $size ) ? $in % $size + 1 : 1 );
           $re->{'LENG'} = $leng1 if $re->{'LENG'} < $leng1;
         }
        unless( $size and $ze = $in % $size ){
         $re->{'KAI'} = print"\n";
        }else{
         $re->{'KAI'} = 0;
        }
       $in++;
      }
     }
    print"\n" if $ze;
  }else{
   m[^ ==> homebrew/|^ ==> Formula|^ ==> Cask] ? next : print"$_\n" for @{$re->{'ARR'}};
  }
  return if $re->{'deps'} or $re->{'LIKE'};
  $re->{'FOR'} = 0 if $re->{'MAC'};
 }
 print "\033[33m$re->{'FILE'}\033[0m" if $re->{'FILE'} and ( $re->{'ALL'} or $re->{'EXC'} or $re->{'KXC'} );
  Nohup_1( $re ) if $re->{'CAS'} or $re->{'FOR'};
}

sub Format_2{
my $re = shift;
 if( $re->{'TT'} or $re->{'DD'} ){ my( $e,$mm,@tt ) = 0;
  for(my $i=$#{$re->{'UNI'}};$i>=0;$i--){
   $mm = () = ${$re->{'UNI'}}[$i] =~ /\|/g;
   if( $mm == $e or ${$re->{'UNI'}}[$i] =~ /require/ or ${$re->{'UNI'}}[$i] =~ /can delete/ ){
    push @tt,${$re->{'UNI'}}[$i];
     $e = $mm - 1;
   }
  } @{$re->{'UNI'}} = reverse @tt;
 }
  my( $cou,@COU2,@COU3,@AR2,@SC,@cn,%ha ) = 0;
 $re->{'KEN'} = 0 if not $re->{'KEN'} or $re->{'KEN'} and $re->{'KEN'} !~ /^\d+$/;
  $cn[0] = $re->{'INF'};
 for my $uni(@{$re->{'UNI'}}){
   if( $re->{'D'} ){
    my @bn = split '\|',$uni;
     $bn[$#bn] =~ s/^-+\s+([^\s]+).+\(can delete\).*\n/$1/ ?
      push @{$SC[$#bn-1]},$bn[$#bn] : push @{$SC[$#bn-1]},0;
       $ha{$bn[$#bn]}++;
        push @cn,$bn[$#bn] if $ha{$bn[$#bn]} < 2;
   }
    my $an = () = $uni =~ /\|/g;
   $uni =~ s/\|/│/g, $uni =~ s/│--/├──/g if $Locale;
  push @COU2,$uni if $an < $re->{'KEN'} + 1;
  $cou = $an if $cou < $an;
 } $re->{'UNI'} = \@COU2 if @COU2 and not $re->{'D'};

 if( $re->{'D'} ){ my %HA;
  for(my $i=$#SC;$i>=0;$i--){
   for my $key(sort @{$SC[$i]}){
     $HA{$key}++;
    push @{$AR2[$i]},"$key\t" if $key and $HA{$key} < 2;
   }
   push @{$AR2[$i]},0 unless @{$AR2[$i]}[0];
  }
  for my $name1(@COU2){ my $flag;
   push @COU3,$name1 if $name1 !~ /\(can delete\)/;
    my( $eq1 ) = $name1 =~ /.*(?:├──|\|--)\s([^\s]+)\s/;
   for(my $i=0;$i<$re->{'KEN'};$i++){ last if $flag;
    for my $name2(@{$AR2[$i]}){
     my( $eq2 ) = $name2 =~ /([^\t\s]+)/;
     if( $eq1 eq $eq2 ){ $flag = 1;
      push @COU3,$name1; last;
     }
    }
   } push @COU3,$name1 if not $re->{'DD'} and not $flag and $name1 =~ s/\(can delete\)//;
  }
 } $re->{'UNI'} = \@COU3 if @COU3;

 unless( $re->{'DDD'} ){ my( $AU,@AUA,@COU,@COU2 );
  $COU2[$_] = 0 for 0..$cou;
  for(my $i=$#{$re->{'UNI'}};$i>=0;$i--){
   my @AN = split '\s{3}',${$re->{'UNI'}}[$i];
   for(my $i=0;$i<=$cou;$i++){
    if( $COU[$i] and $AN[$i] and $AN[$i] =~ /│|\|/ ){ $COU[$i] = 1;
    }elsif( $AN[$i] and $AN[$i] =~ /──|--/ ){ $COU[$i] = 1;
    }else{ $COU[$i] = 0; }
    $AN[$i] =~ s/├──(.+)/└──$1/ or $AN[$i] =~ s/\|--(.+)/`--$1/ if ($COU[$i] - $COU2[$i]) == 1;
     $AU .= $COU[$i] ? "$AN[$i]   " : "    ";
      $COU2[$i] = $COU[$i];
   }
   $AU =~ s/([^\n]+\n).*/$1/;
    push @AUA,$AU;
     $AU = '';
  }
   waitpid $re->{'PID2'},0 if $re->{'DEL'} and rmdir "$re->{'HOME'}/WAIT";
   print"$re->{'INF'}\n" if @AUA;
   print reverse @AUA if not $re->{'DD'} or -t STDOUT;
 }
 if( $re->{'DD'} ){ my( $m,@AR,$flag ) = 0;
   $_->[0] ? push @{$AR[$m++]},@{$_} : next for @AR2;
  if( $re->{'DDD'} ){ my $i;
   waitpid $re->{'PID2'},0 if rmdir "$re->{'HOME'}/WAIT";
   for my $cn(@cn){
    my $file = Dirs_1( "$re->{'CEL'}/$cn",2 );
     $i++, print" check $re->{'CEL'}/$cn  \033[33mbrew cleanup...\033[0m\n" if @$file > 1;
   } exit if $i;
    print STDERR "$re->{'INF'} : deps All delete [y/n]:";
    <STDIN> =~ /^y\n$/ ? system "brew uninstall $re->{'INF'}" : exit;
  } my $in = ( $re->{'KEN'} and $re->{'KEN'} < @AR ) ? $re->{'KEN'} : @AR;
  for(my $e=0;$e<$in;$e++){ $flag++;
   if( $re->{'DDD'} ){
    system "brew uninstall @{$AR[$e]}";
   }else{
    -t STDOUT ? printf "%2s : @{$AR[$e]}\n",$flag : print "@{$AR[$e]}\n";
   }
  }
 }
}

sub Format_3{
 my( $file,$re ) = @_; my( $line1,$line2,$flag1,$flag2,$ca,$fo );
   $line1 = $Locale ? '├──' : '|--';
   $line2 = $Locale ? '└──' : '`--';
  for(my $m=0;$m<@$file;$m++){
   if( $$file[$m] eq 1 and $$file[$m+1] !~ m|^homebrew/| ){
    $fo .= -t STDOUT ? "  \033[33m== homebrew/cask-drivers ==\033[0m\n" : "  == homebrew/cask-drivers ==\n";
    $ca .= -t STDOUT ? "  \033[33m== homebrew/cask-drivers ==\033[0m\n" : "  == homebrew/cask-drivers ==\n";
   }elsif( $$file[$m] eq 2 and $$file[$m+1] !~ m|^homebrew/| ){
    $fo .= -t STDOUT ? "  \033[33m== homebrew/cask-versions ==\033[0m\n" : "  == homebrew/cask-versions ==\n";
    $ca .= -t STDOUT ? "  \033[33m== homebrew/cask-versions ==\033[0m\n" : "  == homebrew/cask-versions ==\n";
   }  next if $$file[$m] =~ m[^[012]$|^homebrew/];

   my( $name,$ver,$desc ) = split '\t',$$file[$m];
    my @cas = split '\t',$re->{'OS'}{"${name}d_cask"} if $re->{'OS'}{"${name}d_cask"};
    my @fom = split '\t',$re->{'OS'}{"${name}formula"} if $re->{'OS'}{"${name}formula"};
     my $desc1 = $JA{$name} ? $JA{$name} : $re->{'OS'}{"${name}c_desc"} ? $re->{'OS'}{"${name}c_desc"} :
        $desc ? $desc : $re->{'OS'}{"${name}c_name"} ? $re->{'OS'}{"${name}c_name"} : '';
      $name = -t STDOUT ? " \033[33mCan't install $name...\033[0m\n".$name :
                          " Can't install $name....\n".$name if $re->{'OS'}{"${name}un_cask"};
      my $dn = $re->{'DMG'}{$name} ? ' (I)' : '';

    for(my $i=0;$i<@cas;$i++){ my $tap = $cas[$i];
     $tap =~ s|.+/(.+)|$1|;
      my $in = $re->{'DMG'}{$tap} ? ' (I)' : '';
     my $desc2 = $JA{$tap} ? $JA{$tap} : $re->{'OS'}{"${tap}c_desc"} ?
        $re->{'OS'}{"${tap}c_desc"} : $re->{'OS'}{"${tap}c_name"} ? $re->{'OS'}{"${tap}c_name"} : '';
     $ca .= "$name$dn\t$desc1\n" if not $flag1 or $flag1 and $flag1 ne $name;
     $ca .= ( $#cas > 0 and $i != $#cas or @fom ) ? "$line1 c $cas[$i]$in\t$desc2\n" :
                                                    "$line2 c $cas[$i]$in\t$desc2\n\n";
     $flag1 = $name;
    }
   if( $re->{'OS'}{"${name}d_cask"} and $re->{'OS'}{"${name}formula"} ){
    for(my $e=0;$e<@fom;$e++){  my $in = $re->{'HASH'}{$fom[$e]} ? ' (I)' : '';
     my $desc3 = $JA{$fom[$e]} ? $JA{$fom[$e]} : $re->{'OS'}{"${fom[$e]}f_desc"} ?
        $re->{'OS'}{"${fom[$e]}f_desc"} : $re->{'OS'}{"${fom[$e]}f_name"} ? $re->{'OS'}{"${fom[$e]}f_name"} : '';
     $ca .= $e != $#fom ? "$line1 f $fom[$e]$in\t$desc3\n" : "$line2 f $fom[$e]$in\t$desc3\n\n";
    }
   }
   unless( $re->{'OS'}{"${name}d_cask"} ){
    for(my $d=0;$d<@fom;$d++){
     my $mem = $re->{'OS'}{"${fom[$d]}alia"} ? $re->{'OS'}{"${fom[$d]}alia"} : $fom[$d];
      my $in = $re->{'HASH'}{$mem} ? ' (I)' : '';
     my $desc4 = $JA{$mem} ? $JA{$mem} : $re->{'OS'}{"${mem}f_desc"} ?
        $re->{'OS'}{"${mem}f_desc"} : $re->{'OS'}{"${mem}f_name"} ? $re->{'OS'}{"${mem}f_name"} : '';
     $fo .= "$name$dn\t$desc1\n" if not $flag2 or $flag2 and $flag2 ne $name;
     $fo .= ( $#fom > 0 and $d != $#fom ) ? "$line1 f $fom[$d]$in\t$desc4\n" :
                                            "$line2 f $fom[$d]$in\t$desc4\n\n";
     $flag2 = $name;
    }
   }
  }
  if( $ca and $fo ){
   if( -t STDOUT ){
    system " printf '\033[?7l' ";
    print"  \033[33m### require Cask and Formula ###\033[0m\n$ca  \033[33m### require Formula ###\033[0m\n$fo";
    system " printf '\033[?7h' ";
   }else{ print"  ### require Cask and Formula ###\n$ca  ### require Formula ###\n$fo"; }
  }
 Nohup_1( $re );
}

sub Nohup_1{
my $re = shift;
 $re->{'NEW'}++, Init_1( $re )
  unless -f "$re->{'HOME'}/font.sh" and -f "$re->{'HOME'}/tie.pl";
   Tied_1( $re,'font2.sh','tie2.pl' );
 $re->{'NEW'}++, Init_1( $re )
  if system 'diff ~/.BREW_LIST/font.sh ~/.BREW_LIST/font2.sh >/dev/null 2>&1 &&\
             diff ~/.BREW_LIST/tie.pl  ~/.BREW_LIST/tie2.pl  >/dev/null 2>&1';
  unlink "$ENV{'HOME'}/.BREW_LIST/font2.sh","$ENV{'HOME'}/.BREW_LIST/tie2.pl";
 my( $time1,$time2 ) = -f $re->{'TXT'} ?
  ( [localtime],[localtime((stat $re->{'TXT'})[9])] ) : ([0,0,0,0,0,1],[0,0,0,0,0,0]);
   if( $time1->[5] > $time2->[5] or $time1->[4] > $time2->[4] or
       $time1->[3] > $time2->[3] or $time1->[2] > $time2->[2] ){
    system 'nohup ~/.BREW_LIST/font.sh 1 1 >/dev/null 2>&1 &';
   }
 exit;
}

sub Tied_1{
my( $re,$an1,$an2 ) = @_; my $i;
 $an1 = $an1 || 'font.sh'; $an2 = $an2 || 'tie.pl';
 unless( $re->{'DATA1'} ){
  while(my $data=<DATA>){
   $i++, next if $data =~ /^__TIE__$/;
    $i ? push @{$re->{'DATA2'}},$data : push @{$re->{'DATA1'}},$data;
  }
 }
 open my $file1,'>',"$re->{'HOME'}/$an1" or die " Tied1 $!\n";
  print $file1 @{$re->{'DATA1'}};
 close $file1;
 open my $file2,'>',"$re->{'HOME'}/$an2"  or die " Tied2 $!\n";
  print $file2 @{$re->{'DATA2'}};
 close $file2;
  chmod 0755,"$re->{'HOME'}/font.sh" if $an1 eq 'font.sh';
}
__END__
#!/bin/bash
 NAME=$(uname)
[[ $1 =~ ^[01]$ ]] || ${die:?input 1 error}
[[ ! $2 || $2 =~ ^[12]$ ]] || ${die:?input 2 error}

math_rm(){ [[ $1 ]] && rm -f ~/.BREW_LIST/{master*,*.html,DBM*} || rm -f ~/.BREW_LIST/{master*,*.html}
                       rm -rf ~/.BREW_LIST/{homebrew*,{0..19},WAIT,LOCK,font2.sh,tie2.pl} ~/.JA_BREWG; }
 TI=$(date +%s)
if [[ $1 -eq 1 ]];then
 LS=$(date -r ~/.BREW_LIST/LOCK "+%Y-%m-%d %H:%M:%S" 2>/dev/null)
 if [[ $LS ]];then
  if [[ "$NAME" = Darwin ]];then
   LS=$(( $(date -jf "%Y-%m-%d %H:%M:%S" "$LS" +%s 2>/dev/null)+60 ))
    [[ $LS && $LS -ne 60 && $TI -gt $LS ]] && math_rm
  else
   LS=$(( $(date +%s --date "$LS" 2>/dev/null)+60 ))
    [[ $LS && $LS -ne 60 && $TI -gt $LS ]] && math_rm
  fi
 fi
fi

if [[ $2 ]];then
 if ! mkdir ~/.BREW_LIST/LOCK 2>/dev/null;then
   exit 2
 fi
 trap 'math_rm 1; exit 1' 1 2 3 15

  LS1=$(date -r ~/.JA_BREW/ja_brew.txt "+%Y-%m-%d %H:%M:%S" 2>/dev/null)
 if [[ $LS1 ]];then
  if [[ "$NAME" = Darwin ]];then
   LS1=$(( $(date -jf "%Y-%m-%d %H:%M:%S" "$LS1" +%s 2>/dev/null)+60*60*24 ))
  else
   LS1=$(( $(date +%s --date "$LS1" 2>/dev/null)+60*60*24 ))
  fi
  if [[ $TI -gt $LS1 ]];then
   git clone -q https://github.com/konnano/JA_BREW ~/.JA_BREWG 2>/dev/null || { math_rm; ${die:?git clone error}; }
    cp ~/.JA_BREWG/* ~/.JA_BREW
     rm -rf ~/.JA_BREWG ~/.JA_BREW/.git
    [[ "$NAME" = Linux ]] && rm ~/.JA_BREW/ja_cask.txt ~/.JA_BREW/ja_tap.txt
  fi
 fi

 if [[ "$NAME" = Darwin ]];then
  if [[ $2 -eq 1 ]];then
    mkdir -p ~/.BREW_LIST/{0..19}
    rm -f ~/.BREW_LIST/keepme.zip
   curl -sko ~/.BREW_LIST/Q_BREW.html https://formulae.brew.sh/formula/index.html ||\
    { math_rm; ${die:?curl 1 error}; }
   curl -sko ~/.BREW_LIST/Q_CASK.html https://formulae.brew.sh/cask/index.html ||\
    { math_rm; ${die:?curl 2 error}; }
     rmdir ~/.BREW_LIST/0
   curl -skLo ~/.BREW_LIST/master1.zip https://github.com/Homebrew/homebrew-cask-fonts/archive/master.zip ||\
    { math_rm; ${die:?curl 3 error}; }
     rmdir ~/.BREW_LIST/1
   curl -skLo ~/.BREW_LIST/master2.zip https://github.com/Homebrew/homebrew-cask-drivers/archive/master.zip ||\
    { math_rm; ${die:?curl 4 error}; }
     rmdir ~/.BREW_LIST/2
   curl -skLo ~/.BREW_LIST/master3.zip https://github.com/Homebrew/homebrew-cask-versions/archive/master.zip ||\
    { math_rm; ${die:?curl 5 error}; }
   zip -jq ~/.BREW_LIST/keepme.zip ~/.BREW_LIST/master1.zip ~/.BREW_LIST/master2.zip ~/.BREW_LIST/master3.zip ||\
    { rm -f keepme.zip; math_rm; ${die:?zip error}; }
     rmdir ~/.BREW_LIST/3
   curl -sko ~/.BREW_LIST/ana1.html https://formulae.brew.sh/analytics/install/30d/index.html ||\
    { math_rm; ${die:?curl 6 error}; }
   curl -sko ~/.BREW_LIST/ana2.html https://formulae.brew.sh/analytics/install/90d/index.html ||\
    { math_rm; ${die:?curl 7 error}; }
     rmdir ~/.BREW_LIST/4
   curl -sko ~/.BREW_LIST/ana3.html https://formulae.brew.sh/analytics/install/365d/index.html ||\
    { math_rm; ${die:?curl 8 error}; }
   curl -sko ~/.BREW_LIST/cna1.html https://formulae.brew.sh/analytics/cask-install/30d/index.html ||\
    { math_rm; ${die:?curl 9 error}; }
     rmdir ~/.BREW_LIST/5
   curl -sko ~/.BREW_LIST/cna2.html https://formulae.brew.sh/analytics/cask-install/90d/index.html ||\
    { math_rm; ${die:?curl a error}; }
   curl -sko ~/.BREW_LIST/cna3.html https://formulae.brew.sh/analytics/cask-install/365d/index.html ||\
    { math_rm; ${die:?curl b error}; }
     rmdir ~/.BREW_LIST/6
   curl -sko ~/.BREW_LIST/req1.html https://formulae.brew.sh/analytics/install-on-request/30d/index.html ||\
    { math_rm; ${die:?curl c error}; }
   curl -sko ~/.BREW_LIST/req2.html https://formulae.brew.sh/analytics/install-on-request/90d/index.html ||\
    { math_rm; ${die:?curl d error}; }
   curl -sko ~/.BREW_LIST/req3.html https://formulae.brew.sh/analytics/install-on-request/365d/index.html ||\
    { math_rm; ${die:?curl e error}; }
     rmdir ~/.BREW_LIST/7
   curl -sko ~/.BREW_LIST/err1.html https://formulae.brew.sh/analytics/build-error/30d/index.html ||\
    { math_rm; ${die:?curl c error}; }
   curl -sko ~/.BREW_LIST/err2.html https://formulae.brew.sh/analytics/build-error/90d/index.html ||\
    { math_rm; ${die:?curl d error}; }
   curl -sko ~/.BREW_LIST/err3.html https://formulae.brew.sh/analytics/build-error/365d/index.html ||\
    { math_rm; ${die:?curl e error}; }
     rmdir ~/.BREW_LIST/8
  fi

  if [[ $2 -eq 2 ]];then
   unzip -jq ~/.BREW_LIST/keepme.zip -d ~/.BREW_LIST || { math_rm; ${die:?unzip error}; }
  fi

   unzip -q ~/.BREW_LIST/master1.zip -d ~/.BREW_LIST || { math_rm; ${die:?unzip 1 error}; }
   unzip -q ~/.BREW_LIST/master2.zip -d ~/.BREW_LIST || { math_rm; ${die:?unzip 2 error}; }
   unzip -q ~/.BREW_LIST/master3.zip -d ~/.BREW_LIST || { math_rm; ${die:?unzip 3 error}; }

perl<<"EOF"
   if( `uname -m` =~ /x86_64/ and -d '/usr/local/Homebrew' ){
    $VERS = 1 if -d '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-versions';
     $DDIR = 1 if -d '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-drivers';
      $FDIR = 1 if -d '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-fonts';
   }else{
    chomp( $MY_BREW = `dirname \$(dirname \$(which brew 2>/dev/null) 2>/dev/null) 2>/dev/null` );
    $VERS = 1 if -d "$MY_BREW/Library/Taps/homebrew/homebrew-cask-versions";
     $DDIR = 1 if -d "$MY_BREW/Library/Taps/homebrew/homebrew-cask-drivers";
      $FDIR = 1 if -d "$MY_BREW/Library/Taps/homebrew/homebrew-cask-fonts";
   }
   opendir $dir1,"$ENV{'HOME'}/.BREW_LIST/homebrew-cask-fonts-master/Casks" or die " DIR1 $!\n";
    for $hand1( readdir($dir1) ){ next if $hand1 =~ /^\./;
      $hand1 =~ s/(.+)\.rb$/$1/;
       if( $FDIR ){
        push @file1,"$hand1\n";
       }else{ $i1 = 1;
        push @file1,"homebrew/cask-fonts/$hand1\n";
       }
   }
   closedir $dir1;
    @file1 = sort @file1;

   opendir $dir2,"$ENV{'HOME'}/.BREW_LIST/homebrew-cask-drivers-master/Casks" or die " DIR2 $!\n";
    for $hand2( readdir($dir2) ){ next if $hand2 =~ /^\./;
      $hand2 =~ s/(.+)\.rb$/$1/;
       if( $DDIR ){
        push @file2,"$hand2\n";
       }else{ $i2 = 1;
        push @file2,"homebrew/cask-drivers/$hand2\n";
       }
    }
   closedir $dir2;
    @file2 = sort @file2;

   opendir $dir3,"$ENV{'HOME'}/.BREW_LIST/homebrew-cask-versions-master/Casks" or die " DIR3 $!\n";
    for $hand3( readdir($dir3) ){ next if $hand3 =~ /^\./;
      $hand3 =~ s/(.+)\.rb$/$1/;
       if( $VERS ){
        push @file3,"$hand3\n";
       }else{ $i3 = 1;
        push @file3,"homebrew/cask-versions/$hand3\n";
       }
    }
   closedir $dir3;
    @file3 = sort @file3;

   ( $i1 and $i2 and $i3 ) ? push @file,"#\n",@file1,@file2,@file3 :
   ( $i1 and $i2 ) ? push @file,"3\n2\n",@file3,@file1,@file2 :
   ( $i1 and $i3 ) ? push @file,"4\n1\n",@file2,@file1,@file3 :
   ( $i2 and $i3 ) ? push @file,"5\n0\n",@file1,@file2,@file3 :
    $i1 ? push @file,"6\n1\n",@file2,"2\n",@file3,@file1 :
    $i2 ? push @file,"7\n0\n",@file1,"2\n",@file3,@file2 :
    $i3 ? push @file,"8\n0\n",@file1,"1\n",@file2,@file3 :
          push @file,"9\n0\n",@file1,"1\n",@file2,"2\n",@file3;

   open $FILE1,'>',"$ENV{'HOME'}/.BREW_LIST/Q_TAP.txt" or die " TAP FILE $!\n";
    print $FILE1 @file;
   close $FILE1;
  rmdir "$ENV{'HOME'}/.BREW_LIST/9"
EOF
  [[ $? -ne 0 ]] && math_rm 1 && ${die:?perl 1 error};

  if [[ $2 -eq 1 ]];then
perl<<"EOF"
   open $FILE2,'<',"$ENV{'HOME'}/.BREW_LIST/Q_CASK.html" or die " FILE2 $!\n";
    while($brew=<$FILE2>){
     if( $brew =~ s|^\s*<td><a href[^>]+>(.+)</a></td>\n|$1| ){
      $tap1 = $brew; next;
     }elsif( not $test and $brew =~ s|^\s*<td>(.+)</td>\n|$1| ){
      $tap2 = $brew;
      $tap2 =~ s/&quot;/"/g;
      $tap2 =~ s/&amp;/&/g;
      $tap2 =~ s/&lt;/</g;
      $tap2 =~ s/&gt;/>/g;
      $test = 1; next;
     }elsif( $test and $brew =~ s|^\s*<td>(.+)</td>\n|$1| ){
      $tap3 = $brew;
      $test = 0;
     }
       push @ANA,$tap1 if $tap1;
      push @file4,"$tap1\t$tap3\t$tap2\n" if $tap1;
     $tap1 = $tap2 = $tap3 = '';
    }
   close $FILE2;
   open $FILE3,'>',"$ENV{'HOME'}/.BREW_LIST/cask.txt" or die " FILE5 $!\n";
    print $FILE3 @file4;
   close $FILE3;

  open $dir1,'<',"$ENV{'HOME'}/.BREW_LIST/cna1.html" or die " cna1 $!\n"; $i1 = 1;
   while( $an1=<$dir1> ){
    next if $an1 =~ /\s--HEAD|\s--with/;
     $HA1{$an1} = $i1++,$AN1 = $an1 if $an1 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $IN1{$AN1} = $an1,$AN1 = 0 if $AN1 and $an1 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir1;
  open $dir2,'<',"$ENV{'HOME'}/.BREW_LIST/cna2.html" or die " cna2 $!\n"; $i2 = 1;
   while( $an2=<$dir2> ){
    next if $an2 =~ /\s--HEAD|\s--with/;
     $HA2{$an2} = $i2++,$AN2 = $an2 if $an2 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $IN2{$AN2} = $an2,$AN2 = 0 if $AN2 and $an2 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir2;
  open $dir3,'<',"$ENV{'HOME'}/.BREW_LIST/cna3.html" or die " cna3 $!\n"; $i3 = 1;
   while( $an3=<$dir3> ){
    next if $an3 =~ /\s--HEAD|\s--with/;
     $HA3{$an3} = $i3++,$AN3 = $an3 if $an3 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $IN3{$AN3} = $an3,$AN3 = 0 if $AN3 and $an3 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir3;
  for($in1=0;$in1<@ANA;$in1++){
   $fom[$in1]  = $ANA[$in1];
   $fom[$in1] .= $HA1{$ANA[$in1]} ? "\t$HA1{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA2{$ANA[$in1]} ? "\t$HA2{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA3{$ANA[$in1]} ? "\t$HA3{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $IN1{$ANA[$in1]} ? "\t$IN1{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $IN2{$ANA[$in1]} ? "\t$IN2{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $IN3{$ANA[$in1]} ? "\t$IN3{$ANA[$in1]}\n" : "\t\n";
  }
  open $dir4,'>',"$ENV{'HOME'}/.BREW_LIST/cna.txt" or die " ana4 $!\n";
   print $dir4 @fom;
  close $dir4;
 rmdir "$ENV{'HOME'}/.BREW_LIST/10"
EOF
  [[ $? -ne 0 ]] && math_rm 1 && ${die:?perl 2 error};
  fi
 else
  curl -so ~/.BREW_LIST/Q_BREW.html https://formulae.brew.sh/formula/index.html || \
   { math_rm; ${die:?curl f error}; }
 curl -sko ~/.BREW_LIST/ana1.html https://formulae.brew.sh/analytics-linux/install/30d/index.html ||\
   { math_rm; ${die:?curl g error}; }
 curl -sko ~/.BREW_LIST/ana2.html https://formulae.brew.sh/analytics-linux/install/90d/index.html ||\
   { math_rm; ${die:?curl h error}; }
 curl -sko ~/.BREW_LIST/ana3.html https://formulae.brew.sh/analytics-linux/install/365d/index.html ||\
   { math_rm; ${die:?curl i error}; }
 curl -sko ~/.BREW_LIST/req1.html https://formulae.brew.sh/analytics-linux/install-on-request/30d/index.html ||\
   { math_rm; ${die:?curl j error}; }
 curl -sko ~/.BREW_LIST/req2.html https://formulae.brew.sh/analytics-linux/install-on-request/90d/index.html ||\
   { math_rm; ${die:?curl k error}; }
 curl -sko ~/.BREW_LIST/req3.html https://formulae.brew.sh/analytics-linux/install-on-request/365d/index.html ||\
   { math_rm; ${die:?curl l error}; }
 curl -sko ~/.BREW_LIST/err1.html https://formulae.brew.sh/analytics-linux/build-error/30d/index.html ||\
   { math_rm; ${die:?curl j error}; }
 curl -sko ~/.BREW_LIST/err2.html https://formulae.brew.sh/analytics-linux/build-error/90d/index.html ||\
   { math_rm; ${die:?curl k error}; }
 curl -sko ~/.BREW_LIST/err3.html https://formulae.brew.sh/analytics-linux/build-error/365d/index.html ||\
   { math_rm; ${die:?curl l error}; }
 fi

 if [[ $2 -eq 1 ]];then
perl<<"EOF"
  open $FILE1,'<',"$ENV{'HOME'}/.BREW_LIST/Q_BREW.html" or die " FILE6 $!\n";
   while($brew=<$FILE1>){
    if( $brew =~ s|^\s*<td><a href[^>]+>(.+)</a></td>\n|$1| ){
     $tap1 = $brew; next;
    }elsif( not $test and $brew =~ s|^\s*<td>(.+)</td>\n|$1| ){
     $tap2 = $brew;
     $test = 1; next;
    }elsif( $test and $brew =~ s|^\s*<td>(.+)</td>\n|$1| ){
     $tap3 = $brew;
     $tap3 =~ s/&quot;/"/g;
     $tap3 =~ s/&amp;/&/g;
     $tap3 =~ s/&lt;/</g;
     $tap3 =~ s/&gt;/>/g;
     $test = 0;
    }
      push @ANA,$tap1 if $tap1;
     push @file1,"$tap1\t$tap2\t$tap3\n" if $tap1;
    $tap1 = $tap2 = $tap3 = '';
   }
  close $FILE1;
  @file1 = sort @file1;
   open $FILE2,'>',"$ENV{'HOME'}/.BREW_LIST/brew.txt" or die " FILE7 $!\n";
    print $FILE2 @file1;
   close $FILE2;

  open $dir1,'<',"$ENV{'HOME'}/.BREW_LIST/ana1.html" or die " ana1 $!\n"; $i1 = 1;
   while( $an1=<$dir1> ){
    next if $an1 =~ /\s--HEAD|\s--with/;
     $HA1{$an1} = $i1++,$AN1 = $an1 if $an1 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $IN1{$AN1} = $an1,$AN1 = 0 if $AN1 and $an1 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir1;
  open $dir2,'<',"$ENV{'HOME'}/.BREW_LIST/ana2.html" or die " ana2 $!\n"; $i2 = 1;
   while( $an2=<$dir2> ){
    next if $an2 =~ /\s--HEAD|\s--with/;
     $HA2{$an2} = $i2++,$AN2 = $an2 if $an2 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $IN2{$AN2} = $an2,$AN2 = 0 if $AN2 and $an2 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir2;
  open $dir3,'<',"$ENV{'HOME'}/.BREW_LIST/ana3.html" or die " ana3 $!\n"; $i3 = 1;
   while( $an3=<$dir3> ){
    next if $an3 =~ /\s--HEAD|\s--with/;
     $HA3{$an3} = $i3++,$AN3 = $an3 if $an3 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $IN3{$AN3} = $an3,$AN3 = 0 if $AN3 and $an3 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir3;
  open $dir4,'<',"$ENV{'HOME'}/.BREW_LIST/req1.html" or die " req1 $!\n"; $i4 = 1;
   while( $re1=<$dir4> ){
    next if $re1 =~ /\s--HEAD|\s--with/;
     $HA4{$re1} = $i4++,$RE1 = $re1 if $re1 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $EQ1{$RE1} = $re1,$RE1 = 0 if $RE1 and $re1 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir4;
  open $dir5,'<',"$ENV{'HOME'}/.BREW_LIST/req2.html" or die " req2 $!\n"; $i5 = 1;
   while( $re2=<$dir5> ){
    next if $re2 =~ /\s--HEAD|\s--with/;
     $HA5{$re2} = $i5++,$RE2 = $re2 if $re2 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $EQ2{$RE2} = $re2,$RE2 = 0 if $RE2 and $re2 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir5;
  open $dir6,'<',"$ENV{'HOME'}/.BREW_LIST/req3.html" or die " req3 $!\n"; $i6 = 1;
   while( $re3=<$dir6> ){
    next if $re3 =~ /\s--HEAD|\s--with/;
     $HA6{$re3} = $i6++,$RE3 = $re3 if $re3 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $EQ3{$RE3} = $re3,$RE3 = 0 if $RE3 and $re3 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir6;
  open $dir7,'<',"$ENV{'HOME'}/.BREW_LIST/err1.html" or die " err1 $!\n"; $i7 = 1;
   while( $en1=<$dir7> ){
    next if $en1 =~ /\s--HEAD|\s--with/;
     $HA7{$en1} = $i7++,$EN1 = $en1 if $en1 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $ER1{$EN1} = $en1,$EN1 = 0 if $EN1 and $en1 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir7;
  open $dir8,'<',"$ENV{'HOME'}/.BREW_LIST/err2.html" or die " err2 $!\n"; $i8 = 1;
   while( $en2=<$dir8> ){
    next if $en2 =~ /\s--HEAD|\s--with/;
     $HA8{$en2} = $i8++,$EN2 = $en2 if $en2 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $ER2{$EN2} = $en2,$EN2 = 0 if $EN2 and $en2 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir8;
  open $dir9,'<',"$ENV{'HOME'}/.BREW_LIST/err3.html" or die " err3 $!\n"; $i9 = 1;
   while( $en3=<$dir9> ){
    next if $en3 =~ /\s--HEAD|\s--with/;
     $HA9{$en3} = $i9++,$EN3 = $en3 if $en3 =~ s|^\s*<td><a[^>]+><code>(.+)</code></a></td>\n|$1|;
      $ER3{$EN3} = $en3,$EN3 = 0 if $EN3 and $en3 =~ s|^\s*<td[^>]+>(.+)</td>\n|$1|;
   }
  close $dir9;

  for($in1=0;$in1<@ANA;$in1++){
   $fom[$in1]  = $ANA[$in1];
   $fom[$in1] .= $HA1{$ANA[$in1]} ? "\t$HA1{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA2{$ANA[$in1]} ? "\t$HA2{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA3{$ANA[$in1]} ? "\t$HA3{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $IN1{$ANA[$in1]} ? "\t$IN1{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $IN2{$ANA[$in1]} ? "\t$IN2{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $IN3{$ANA[$in1]} ? "\t$IN3{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA4{$ANA[$in1]} ? "\t$HA4{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA5{$ANA[$in1]} ? "\t$HA5{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA6{$ANA[$in1]} ? "\t$HA6{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $EQ1{$ANA[$in1]} ? "\t$EQ1{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $EQ2{$ANA[$in1]} ? "\t$EQ2{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $EQ3{$ANA[$in1]} ? "\t$EQ3{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA7{$ANA[$in1]} ? "\t$HA7{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA8{$ANA[$in1]} ? "\t$HA8{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $HA9{$ANA[$in1]} ? "\t$HA9{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $ER1{$ANA[$in1]} ? "\t$ER1{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $ER2{$ANA[$in1]} ? "\t$ER2{$ANA[$in1]}" : "\t";
   $fom[$in1] .= $ER3{$ANA[$in1]} ? "\t$ER3{$ANA[$in1]}\n" : "\t\n";
  }
  open $dir4,'>',"$ENV{'HOME'}/.BREW_LIST/ana.txt" or die " ana4 $!\n";
   print $dir4 @fom;
  close $dir4;
 rmdir "$ENV{'HOME'}/.BREW_LIST/11"
EOF
 [[ $? -ne 0 ]] && math_rm 1 && ${die:?perl 3 error};

  perl ~/.BREW_LIST/tie.pl || { math_rm 1 && ${die:?perl tie1 error}; }

  if [[ "$NAME" = Darwin ]];then
   mv ~/.BREW_LIST/DBMG.db ~/.BREW_LIST/DBM.db
  else
   mv ~/.BREW_LIST/DBMG.dir ~/.BREW_LIST/DBM.dir
   mv ~/.BREW_LIST/DBMG.pag ~/.BREW_LIST/DBM.pag
  fi
 fi
  if [[ $2 -eq 2 ]];then
   perl ~/.BREW_LIST/tie.pl 1 || { math_rm 1 && ${die:?perl tie2 error}; }
  fi
rm -rf ~/.BREW_LIST/19
 math_rm
fi
__TIE__
use strict;
use warnings;
use NDBM_File;
use Fcntl ':DEFAULT';

my( $IN,$KIN,$SPA ) = ( 0,0,0 );
my $UNAME = `uname -m` !~ /arm64|aarch64/ ? 'x86_64' : 'arm64';
my $CPU = $UNAME =~ /arm64/ ? 'arm\?' : 'intel\?';
my( $re,$OS_Version,$OS_Version2,%MAC_OS,%HAN,$Xcode,$RPM,$CAT,@BREW,@CASK );
chomp( my $MY_BREW = `dirname \$(dirname \$(which brew 2>/dev/null) 2>/dev/null) 2>/dev/null` );

if( $^O eq 'darwin' ){ $re->{'MAC'} = 1;
 $OS_Version = `sw_vers -productVersion`;
  $OS_Version =~ s/^(10\.1[0-5]).*\n/$1/;
   $OS_Version =~ s/^10\.9.*\n/10.09/;
    $OS_Version =~ s/^(1[1-3]).+\n/$1.0/;
 $OS_Version2 = $CPU eq 'arm\?' ? "${OS_Version}M1" : $OS_Version;

 unless( $ARGV[0] ){
  $Xcode = `xcodebuild -version 2>/dev/null|\
            sed -E '/Xcode/!d;s/[^0-9]*([0-9.]*)/\\1/;s/^([1-9]\\.)/0\\1/'` || 0;
  $re->{'CLANG'} = `/usr/bin/clang --version 2>/dev/null|sed -E '/Apple/!d;s/.*clang-([^.]*).*/\\1/'` || 0;
  $re->{'CLT'} = `pkgutil --pkg-info=com.apple.pkg.CLTools_Executables 2>/dev/null|\
                  sed '/version/!d;s/[^0-9]*\\([0-9]*\\.[0-9]*\\).*/\\1/'` || 0;
 }
  %MAC_OS = ('ventura'=>'13.0','monterey'=>'12.0','big_sur'=>'11.0','catalina'=>'10.15',
             'mojave'=>'10.14','high_sierra'=>'10.13','sierra'=>'10.12','el_capitan'=>'10.11',
             'yosemite'=>'10.10','mavericks'=>'10.09','mountain_lion'=>'10.08','lion'=>'10.07');
     %HAN = ('newer'=>'>','older'=>'<');

  if( $CPU eq 'intel\?' and -d '/usr/local/Homebrew' ){ $re->{'CEL'} = '/usr/local/Cellar';
    $re->{'FON'} = '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-fonts';
     $re->{'COM'} = '/usr/local/share/zsh/site-functions';
   unless( $ARGV[0] ){
    Dirs_1( '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask/Casks',0,1 );
     Dirs_1( '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula',0,0 );
      Dirs_1( '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Aliases',0,0 );
       Dirs_1( '/usr/local/Homebrew/Library/Taps',1,0 );
   }
    Dirs_1( '/usr/local/Homebrew/Library/Taps/homebrew',1,1 );
  }else{ $re->{'CEL'} = "$MY_BREW/Cellar";
     $re->{'FON'} = "$MY_BREW/Library/Taps/homebrew/homebrew-cask-fonts";
      $re->{'COM'} = "$MY_BREW/share/zsh/site-functions";
   unless( $ARGV[0] ){
    Dirs_1( "$MY_BREW/Library/Taps/homebrew/homebrew-cask/Casks",0,1 );
     Dirs_1( "$MY_BREW/Library/Taps/homebrew/homebrew-core/Formula",0,0 );
      Dirs_1( "$MY_BREW/Library/Taps/homebrew/homebrew-core/Aliases",0,0 );
       Dirs_1( "$MY_BREW/Library/Taps",1,0 );
   }
    Dirs_1( "$MY_BREW/Library/Taps/homebrew",1,1 );
  }
 rmdir "$ENV{'HOME'}/.BREW_LIST/12";
}else{ $re->{'LIN'} = 1;
 $re->{'CEL'} = "$MY_BREW/Cellar";
  $re->{'COM'} = "$MY_BREW/share/zsh/site-functions";
   $OS_Version2 = $UNAME =~ /x86_64/ ? 'Linux' : 'LinuxM1';
    $MY_BREW = -d "$MY_BREW/Homebrew" ? $MY_BREW.'/Homebrew' : $MY_BREW;
 Dirs_1( "$MY_BREW/Library/Taps/homebrew/homebrew-core/Formula",0,0 );
  Dirs_1( "$MY_BREW/Library/Taps/homebrew/homebrew-core/Aliases",0,0 );
   Dirs_1( "$MY_BREW/Library/Taps",1,0 );
    $MY_BREW =~ s|/Homebrew$||;
}

sub Dirs_1{
my( $dir,$ls,$cask ) = @_;
 opendir my $DIR,$dir or die " DIR $!\n";
  for my $an(sort readdir $DIR){ next if $an =~ /^\./;
   next if $ls and $an =~ /homebrew$|homebrew-core$|homebrew-cask$|homebrew-bundle$|homebrew-services$/;
   ( -d "$dir/$an" ) ? Dirs_1( "$dir/$an",$ls,$cask ) : ( -l "$dir/$an" ) ? push @{$re->{'ALIA'}},"$dir/$an" :
   ( $cask and $an =~ /\.rb$/ ) ? push @CASK,"$dir/$an" : ( $an =~ /\.rb$/ ) ? push @BREW,"$dir/$an" : 0;
  }
 closedir $DIR;
}

 my $DBM = $ARGV[0] ? 'DBM' : 'DBMG';
tie my %tap,'NDBM_File',"$ENV{'HOME'}/.BREW_LIST/$DBM",O_RDWR|O_CREAT,0666 or die " tie DBM $!\n";
unless( $ARGV[0] ){
 for my $alias(@{$re->{'ALIA'}}){
  my $hand = readlink $alias;
  $alias =~ s|.+/(.+)|$1|;
   $hand =~ s|.+/(.+)\.rb|$1|;
  $tap{"${alias}alia"} = $hand;
  $tap{"${hand}alias"} .= "$alias\t";
 }
  my( $in,$e ) = @BREW >> 2;
   my @in = ( $in << 1,($in << 1) + $in );
 for my $dir1(@BREW){ my $bot;
  if( $re->{'MAC'} ){ $e++;
   $e == $in ? rmdir "$ENV{'HOME'}/.BREW_LIST/13" :
   $e == $in[0] ? rmdir "$ENV{'HOME'}/.BREW_LIST/14" :
   $e == $in[1] ? rmdir "$ENV{'HOME'}/.BREW_LIST/15" : 0;
  }
  my( $name ) = $dir1 =~ m|.+/(.+)\.rb|;
   $tap{"${name}core"} = $dir1;
  open my $BREW,'<',$dir1 or die " tie Info_1 $!\n";
   while(my $data=<$BREW>){
     if( $data =~ /^\s*bottle\s+do/ ){
      $KIN = $bot = 1; next;
     }elsif( $data =~ /^\s*rebuild/ and $KIN == 1 ){
       next;
     }elsif( $data !~ /^\s*end/ and $KIN == 1 ){
       if( $data =~ /.*,\s+all:/ ){
        $tap{"${name}13.0M1"}= $tap{"${name}13.0"}  = $tap{"${name}12.0M1"}=
        $tap{"${name}12.0"}  = $tap{"${name}11.0M1"}= $tap{"${name}11.0"}  =
        $tap{"${name}10.15"} = $tap{"${name}10.14"} = $tap{"${name}10.13"} =
        $tap{"${name}10.12"} = $tap{"${name}10.11"} = $tap{"${name}10.10"} =
        $tap{"${name}10.09"} = $tap{"${name}Linux"} = 1;
       }
        $tap{"$name$data"} =
        $data =~ s/.*arm64_ventura:.*\n/13.0M1/  ? 1 :
        $data =~ s/.*ventura:.*\n/13.0/          ? 1 :
        $data =~ s/.*arm64_monterey:.*\n/12.0M1/ ? 1 :
        $data =~ s/.*monterey:.*\n/12.0/         ? 1 :
        $data =~ s/.*arm64_big_sur:.*\n/11.0M1/  ? 1 :
        $data =~ s/.*big_sur:.*\n/11.0/          ? 1 :
        $data =~ s/.*catalina:.*\n/10.15/        ? 1 :
        $data =~ s/.*mojave:.*\n/10.14/          ? 1 :
        $data =~ s/.*high_sierra:.*\n/10.13/     ? 1 :
        $data =~ s/.*sierra:.*\n/10.12/          ? 1 :
        $data =~ s/.*el_capitan:.*\n/10.11/      ? 1 :
        $data =~ s/.*yosemite:.*\n/10.10/        ? 1 :
        $data =~ s/.*x86_64_linux:.*\n/Linux/    ? 1 : next; # x86_64 #
       next;
     }elsif( $data =~ /^\s*end/ and $KIN == 1 ){
      $KIN = 0; next;
     }
   if( $data !~ /^\s*end/ and $IN ){ $SPA++ if $data =~ /\s+do$/; next;
   }elsif( $data =~ /^\s*end/ and $SPA > 1 and $IN ){ $SPA--; next;
   }elsif( $data =~ /^\s*end/ and $IN ){ $SPA = $IN = 0; next;
   }
    if( $re->{'MAC'} ){
      $SPA = $IN = 1, next if $data =~ /^\s*on_linux\s+do/;
    }else{
      $SPA = $IN = 1, next if $data =~ /^\s*on_macos\s+do/;
    }
     if( $data =~ /^\s*head\s+do/ ){ $SPA = $IN = 1; next;
     }elsif( $data =~ /^\s*on_intel\s+do/ and $UNAME =~ /arm64/ or
             $data =~ /^\s*on_arm\s+do/ and $UNAME =~ /x86_64/ ){ $SPA = $IN = 1; next;
     }elsif( my( $ha1,$ha2 ) = $data =~ /^\s*on_([^\s]+)\s+:or_([^\s]+)\s+do/ ){
         $SPA = $IN = 1 if $re->{'LIN'} or eval "$MAC_OS{$ha1} $HAN{$ha2} $OS_Version"; next;
     }elsif( my( $ha3,$ha4 ) = $data =~ /^\s+on_system\s+:linux,\s+macos:\s+:(.+)_or_([^\s]+)\s+do/ ){
         $SPA = $IN = 1 if $re->{'MAC'} and eval "$MAC_OS{$ha3} $HAN{$ha4} $OS_Version"; next;
     }

      if( my( $ls1,$ls2 ) =
        $data =~ /^\s*depends_on\s+xcode:.+if\s+MacOS::CLT\.version\s+([^\s]+)\s+"([\d.]+)"/ ){
         if( $re->{'MAC'} and not $Xcode and $ls1 =~ /^[<=>]+$/ and eval "$re->{'CLT'} $ls1 $ls2" ){
          $tap{"${name}un_xcode"} = 1;
           $tap{"${name}un_xcode"} = 0 if $tap{"$name$OS_Version2"};
         }elsif( $re->{'LIN'} ){
          $tap{"${name}un_Linux"} = 1;
           $tap{"${name}un_Linux"} = 0 if $tap{"${name}Linux"};
         } next;
      }elsif( $data =~ s/^\s*depends_on\s+xcode:.+"([^"]+)",\s+:build.*\n/$1/ ){
         $data =~ s/^(\d\.)/0$1/;
         if( $re->{'MAC'} and $data gt $Xcode ){
          $tap{"${name}un_xcode"} = 1;
           $tap{"${name}un_xcode"} = 0 if $tap{"$name$OS_Version2"};
         }elsif( $re->{'LIN'} ){
          $tap{"${name}un_Linux"} = 1;
           $tap{"${name}un_Linux"} = 0 if $tap{"${name}Linux"};
         } next;
      }elsif( $data =~ /^\s*depends_on\s+xcode:\s+:build/ ){
         if( $re->{'MAC'} and not $Xcode ){
          $tap{"${name}un_xcode"} = 1;
           $tap{"${name}un_xcode"} = 0 if $tap{"$name$OS_Version2"};
         }elsif( $re->{'LIN'} ){
          $tap{"${name}un_Linux"} = 1;
           $tap{"${name}un_Linux"} = 0 if $tap{"${name}Linux"};
         } next;
      }elsif( $data =~ s/^\s*depends_on\s+xcode:\s*"([^"]+)".*\n/$1/ ){
        $data =~ s/^(\d\.)/0$1/;
         if( $re->{'MAC'} and $data gt $Xcode ){
           $tap{"${name}un_xcode"} = 1;
            $tap{"$name$OS_Version2"} = 0;
         }elsif( $re->{'LIN'} ){
           $tap{"${name}un_Linux"} = 1;
            $tap{"${name}Linux"} = 0; # bottle #
         } next;
      }elsif( $data =~ s/\s*depends_on\s+arch:\s+:([^\s]+).*\n/$1/ and $UNAME ne $data ){
          $tap{"${name}un_xcode"} = $tap{"${name}un_Linux"} =1;
          $tap{"$name$OS_Version2"} = $tap{"${name}Linux"} = 0;
           next;
      }

     if( $data =~ /^\s*depends_on\s+"[^"]+"\s*=>\s+:test/ ){
         next;
     }elsif( $re->{'MAC'} and my( $ds,$ds1,$ds2,$ds3 ) =
       $data =~ /^\s*depends_on\s+"([^"]+)"\s+=>\s+:build.+if\s+Development[^\s]+\s+([^\s]+)\s+(\d+).+CPU\.([^\s]+)/ ){
        if( $ds1 =~ /^[<=>]+$/ and eval "$re->{'CLANG'} $ds1 $ds2" and $CPU eq $ds3 ){
         $tap{"${ds}build"} .= "$name\t" unless $tap{"$name$OS_Version2"};
          $tap{"${name}deps_b"} .= "$ds\t";
        }
     }elsif( $re->{'MAC'} and my( $ds4,$ds5,$ds6 ) =
       $data =~ /^\s*depends_on\s+"([^"]+)"\s+=>\s+\[?:build.+if\s+Development[^\s]+\s+([^\s]+)\s+(\d+)/ ){
        if( $ds5 =~ /^[<=>]+$/ and eval "$re->{'CLANG'} $ds5 $ds6" ){
         $tap{"${ds4}build"} .= "$name\t" unless $tap{"$name$OS_Version2"};
          $tap{"${name}deps_b"} .= "$ds4\t";
        }
     }elsif( $re->{'MAC'} and my( $ds7,$ds8,$ds9 ) =
       $data =~ /^\s*depends_on\s+"([^"]+)"\s+if\s+Development[^\s]+\s+([^\s]+)\s+(\d+)/ ){
        if( $ds8 =~ /^[<=>]+$/ and eval "$re->{'CLANG'} $ds8 $ds9" ){
         $tap{"${ds7}build"} .= "$name\t" unless $tap{"$name$OS_Version2"};
          $tap{"${name}deps_b"} .= "$ds7\t";
        }
     }elsif( $re->{'MAC'} and $data =~ s/^\s*depends_on\s+"([^"]+)".+MacOS\.version\.outdated_release\?\n/$1/ ){
       push @{$re->{'OS'}},"$name,$data";
     }elsif( $re->{'LIN'} and $data =~ s/^\s*uses_from_macos\s+"([^"]+)"\s+=>\s+\[?:build.*\n/$1/ ){
       $tap{"${data}build"} .= "$name\t" unless $tap{"$name$OS_Version2"};
        $tap{"${name}deps_b"} .= "$data\t";
     }elsif( my( $us1,$us2 ) =
       $data =~ /^\s*uses_from_macos\s+"([^"]+)"\s+=>.+:build,\s+since:\s+:([^\s]+)/ ){
        if( $re->{'LIN'} or $OS_Version < $MAC_OS{$us2} ){
         $tap{"${us1}build"} .= "$name\t" unless $tap{"$name$OS_Version2"};
          $tap{"${name}deps_b"} .= "$us1\t";
        }
     }elsif( $data =~ s/^\s*depends_on\s+"([^"]+)"\s+=>\s+\[?:build.*\n/$1/ ){
        $tap{"${data}build"} .= "$name\t" unless $tap{"$name$OS_Version2"};
         $tap{"${name}deps_b"} .= "$data\t";
          push @{$re->{'OS'}},"$name,$data,1" unless $tap{"$name$OS_Version2"};
     }elsif( my( $us3,$us4 ) = $data =~ /^\s*uses_from_macos\s+"([^"]+)",\s+since:\s+:([^\s]+)/ ){
       if( $re->{'LIN'} or $re->{'MAC'} and $OS_Version < $MAC_OS{$us4} ){
        $tap{"${us3}uses"} .= "$name\t";
         $tap{"${name}deps"} .= "$us3\t";
       }
     }elsif( $re->{'LIN'} and $data =~ s/^\s*uses_from_macos\s+"([^"]+)"(?!.+:test).*\n/$1/ ){
       $tap{"${data}uses"} .= "$name\t";
        $tap{"${name}deps"} .= "$data\t";
     }elsif( $re->{'LIN'} and
             my( $us5,$us6 ) = $data =~ /^\s*depends_on\s+"([^"]+)".+OS::Linux[^\s]+\s+([^\s]+)/ ){
      if( $us6 =~ /^[<=>]+$/ and eval "$RPM $us6 $CAT" ){
       $tap{"${us5}uses"} .= "$name\t";
        $tap{"${name}deps"} .= "$us5\t";
      }
     }elsif( $re->{'LIN'} and
             my( $us7 ) = $data =~ /^\s*depends_on\s+"([^"]+)".*\["glibc"]\.any_version_installed/ ){
      if( -d "$MY_BREW/Cellar/glibc" ){
       $tap{"${us7}uses"} .= "$name\t";
        $tap{"${name}deps"} .= "$us7\t";
      }
     }elsif( $data =~ s/^\s*depends_on\s+"([^"]+)".*\n/$1/ ){
       $tap{"${data}uses"} .= "$name\t";
        $tap{"${name}deps"} .= "$data\t";
         push @{$re->{'OS'}},"$name,$data,1";
     }

      if( not $bot and $data =~ s/^\s*version\s+"([^"]+)".*\n/$1/ ){
        $tap{"${name}f_version"} = $data;
      }elsif( not $bot and $data =~ s/^\s*desc\s+"([^"]+)".*\n/$1/ ){
        $tap{"${name}f_desc"} = $data;
      }elsif( not $bot and $data =~ s/^\s*name\s+"([^"]+)".*\n/$1/ ){
        $tap{"${name}f_name"} = $data;
      }elsif( not $bot and $data =~ s/^\s*revision\s+(\d+).*\n/$1/ ){
        $tap{"${name}revision"} = "_$data";
      }

    if( $data =~ /^\s*keg_only.*macos/ ){
      $tap{"${name}keg"} = 1;
    }elsif( $data =~ /^\s*keg_only/ ){
      $tap{"${name}keg_Linux"} = $tap{"${name}keg"} = 1;
    }elsif( $data =~ /^\s*depends_on\s+:macos/ ){
      $tap{"${name}un_Linux"} = 1; $tap{"${name}Linux"} = 0;
    }elsif( $data =~ /^\s*depends_on\s+:linux/ ){
      $tap{"${name}un_xcode"} = 1;
    }elsif( my( $cs1,$cs2,$cs3 ) =
           $data =~ /^\s*depends_on\s+macos:\s+:([^\s]*)\s+if\s+Development[^\s]+\s+([^\s]+)\s+(\d+)/ ){
     $tap{"${name}un_xcode"} = 1 if $re->{'MAC'} and
      $cs2 =~ /^[<=>]+$/ and eval "$re->{'CLANG'} $cs2 $cs3" and $MAC_OS{$cs1} > $OS_Version;
       $tap{"${name}USE_OS"} = $cs1;
    }elsif( $data =~ s/^\s*depends_on\s+macos:\s+:([^\s]*).*\n/$1/ ){
      $tap{"${name}un_xcode"} = 1 if $re->{'MAC'} and $OS_Version and $MAC_OS{$data} > $OS_Version;
       $tap{"${name}USE_OS"} = $data;
    }elsif( $data =~ s/^\s*depends_on\s+maximum_macos:\s+\[?:([^,\s]+).*\n/$1/ ){
      $tap{"${name}un_xcode"} = 1 if $re->{'MAC'} and $OS_Version and $MAC_OS{$data} < $OS_Version;
    }
   }
  close $BREW;
 }

 if( $re->{'MAC'} ){ my %HA;
  rmdir "$ENV{'HOME'}/.BREW_LIST/16";
  for(@{$re->{'OS'}}){
   my( $name,$data,$ls ) = split ',';
   if( not $ls and $MAC_OS{$tap{"${data}USE_OS"}} <= $OS_Version ){
    $tap{"${data}build"} .= "$name\t" unless $tap{"$name$OS_Version2"};
     $tap{"${name}deps_b"} .= "$data\t";
   }elsif( $ls and $tap{"${data}USE_OS"} and $MAC_OS{$tap{"${data}USE_OS"}} > $OS_Version ){
    Uses_1( $name,\%HA );
   }
  }
 }

 sub Uses_1{
 my( $name,$HA ) = @_;
  for my $ls(split '\t',$name){
   $HA->{$ls}++;
   if( $HA->{$ls} < 2 ){
    $tap{"$ls$OS_Version2"} = 0 if $tap{"$ls$OS_Version2"};
     $tap{"${ls}un_xcode"} = 1;
   }
   Uses_1( $tap{"${ls}uses"},$HA ) if $tap{"${ls}uses"};
  }
 }

 sub Glob_1{
 my $sub = sub{ my( $name,$ls ) = @_;
               if( $re->{'LIN'} and ( $ls eq 'gcc' or $ls eq 'glibc' ) ){
                $tap{"${ls}uses"} .= "$name\t";
                $tap{"${name}deps"} .= "$ls\t";
               }elsif( $re->{'LIN'} ){
                $tap{"${ls}uses_proc"} .= "$name\t";
               }elsif( $re->{'MAC'} ){
                $tap{"${ls}uses"} .= "$name\t";
                $tap{"${name}deps"} .= "$ls\t";
               }
              };

 my( $brew,$mine,$loop ) = @_;
  my @GLOB = $brew ? glob "$re->{'CEL'}/$brew/*" : glob "$re->{'CEL'}/*/*";
  for my $glob(@GLOB){ my($name) = $glob =~ m|$re->{'CEL'}/([^/]+)/.*|;
   if( -f "$glob/INSTALL_RECEIPT.json" ){ my $in;
    open my $CEL,'<',"$glob/INSTALL_RECEIPT.json" or die " GLOB $!\n";
     while(my $cel=<$CEL>){
      unless( $cel =~ /\n/ ){
       $cel =~ s/.+"runtime_dependencies":\[([^]]*)].+/$1/;
       my @HE = $cel =~ /{"full_name":"([^"]+)","version":"[^"]+"}/g;
       for my $ls1(@HE){ my( %HA,%AL,$ne );
        if( $tap{"${ls1}uses"} ){ $HA{$_}++ for split '\t',$tap{"${ls1}uses"} }
        unless( $HA{$name} ){
         if( $loop ){ return if $ls1 eq $mine;
         }else{ next unless Glob_1( $ls1,$name,1 );
           if( $tap{"${ls1}alias"} and $tap{"${name}deps"} ){
            $AL{$_}++ for split '\t',$tap{"${ls1}alias"};
            $AL{$_} ? $ne++ : 0 for split '\t',$tap{"${name}deps"};
           } next if $ne;
          $sub->( $name,$ls1 );
         }
        }
       }
      }else{ my( %HA,%AL,$ne );
       if( $in or $cel =~ /runtime_dependencies/ ){ $in = $cel =~ /]/ ? last : 1;
        my( $ls2 ) = $cel =~ /"full_name":\s*"([^"]+)".*/ ? $1 : next;
        if( $tap{"${ls2}uses"} ){ $HA{$_}++ for split '\t',$tap{"${ls2}uses"} }
        unless( $HA{$name} ){
         if( $loop ){ return if $ls2 eq $mine;
         }else{ next unless Glob_1( $ls2,$name,1 );
           if( $tap{"${ls2}alias"} and $tap{"${name}deps"} ){
            $AL{$_}++ for split '\t',$tap{"${ls2}alias"};
            $AL{$_} ? $ne++ : 0 for split '\t',$tap{"${name}deps"};
           } next if $ne;
          $sub->( $name,$ls2 );
         }
        }
       }
      }
     }
    close $CEL;
   }
  }1;
 } Glob_1;
}
rmdir "$ENV{'HOME'}/.BREW_LIST/16";

sub Version_1{
 my @ls1 = split '\.|-|_',$_[0];
 $_[1] ? my @ls2 = split '\.|-|_',$_[1] : return 1;
 my $i = 0;
  for(;$i<@ls2;$i++){
   if( $ls1[$i] and $ls2[$i] =~ /[^\d]/ ){
     if( $ls1[$i] gt $ls2[$i] ){ return 1;
     }elsif( $ls1[$i] lt $ls2[$i] ){ return;
     }
   }else{
     if( $ls1[$i] and $ls1[$i] > $ls2[$i] ){ return 1;
     }elsif( $ls1[$i] and $ls1[$i] < $ls2[$i] ){ return;
     }
   }
  }
 $ls1[$i] ? 1 : 0;
}
  my $FON;
 if( $re->{'MAC'} ){
 rmdir "$ENV{'HOME'}/.BREW_LIST/17";
 my( $IN,$in,$e ) = ( 0,@CASK >> 1,0 ); $tap{'fontlist'} = '';
  for my $dir2(@CASK){ my $ver;
   rmdir "$ENV{'HOME'}/.BREW_LIST/18" if $in == $e++;
   my( $name ) = $dir2 =~ m|.+/(.+)\.rb|;
    $tap{"${name}cask"} = $dir2;
     my( $IF1,$IF2,$ELIF,$ELS,$FI ) = ( 1,0,0,0,1 );
    $tap{"${name}d_cask"} = $tap{"${name}formula"} = '';
   open my $BREW,'<',$dir2 or die " tie Info_2 $!\n";
    while(my $data=<$BREW>){
     if( $name =~ /^font-/ and $FI ){
      $ver = $1 if $data =~ /^\s*version\s+"([^"]+)"/;
      ( $tap{"${name}font"} ) = $data =~ /^\s*url\s+"(.+(?:ttf|otf|dfont))"/;
       if( $tap{"${name}font"} ){
        $tap{"${name}font"} =~ s/\Q#{version}\E/$ver/g;
         $tap{'fontlist'} .= "$name\t";
          $FON .= "$name \\\n" if -d $re->{'FON'}; $FI = 0;
       }
     }
     if( my( $ls1,$ls2 ) = $data =~ /^\s*depends_on\s+macos:\s+"([^\s]+)\s+:([^\s]+)"/ ){
       $tap{"${name}un_cask"} = 1 unless $ls1 !~ /^[<=>]+$/ or eval "$OS_Version $ls1 $MAC_OS{$ls2}";
     }elsif( $data =~ s/^\s*depends_on\s+formula:\s+"([^"]+)".*\n/$1/ ){
       $tap{"${name}formula"} .= "$data\t";
        $tap{"${data}u_form"} .= "$name\t"
         if not $tap{"${data}u_form"} or $tap{"${data}u_form"} !~ /$name\t/;
     }elsif( $data =~ /^\s*depends_on\s+cask:\s+/ or $IN ){
      if( $data =~ /^\s*depends_on\s+cask:\s+\[/ ){ $IN = 1; next; }
       if( $data =~ /^\s*\]/ ){ $IN = 0; next; }
      $data =~ s/^\s*"([^"]+)".*\n/$1/;
       $data =~ s/^\s*depends_on\s+cask:\s+"([^"]+)".*\n/$1/;
        $tap{"${name}d_cask"} .= "$data\t";
         $data =~ s|.+/([^/]+)|$1|;
          $tap{"${data}u_cask"} .= "$name\t"
           if not $tap{"${data}u_cask"} or $tap{"${data}u_cask"} !~ /$name\t/;
     }elsif( my( $ls4,$ls5 ) = $data =~ /^\s*if\s+MacOS\.version\s+([^\s]+)\s+:([^\s]+)/ ){
       $IF1 = 0; $ELIF = $ELS = 1;
       if( $ls4 =~ /^[<=>]+$/ and eval "$OS_Version $ls4 $MAC_OS{$ls5}" ){
        $ELS = $ELIF = 0; $IF2 = 1;
       }
     }elsif( my( $ls6,$ls7 ) = $data =~ /^\s*elsif\s+MacOS\.version\s+([^\s]+)\s+:([^\s]+)/ and $ELIF ){
       if( $ls6 =~ /^[<=>]+$/ and eval "$OS_Version $ls6 $MAC_OS{$ls7}" ){
        $ELS = $ELIF  = 0; $IF2 = 1;
       }
     }elsif( $data =~ /^\s*else/ and $ELS ){
       $IF2 = 1;
     }elsif(( $data =~ s/^\s*version\s+"([^"]+)".*\n/$1/ or
              $data =~ s/^\s*version\s+:([^\s]+).*\n/$1/ ) and ( $IF1 or $IF2 )){
       $tap{"${name}c_version"} = $data;
        $IF1 = $IF2 = 0;
     }elsif( $data =~ s/^\s*desc\s+"([^"]+)".*\n/$1/ ){
       $tap{"${name}c_desc"} = $data;
     }elsif( $data =~ s/^\s*name\s+"([^"]+)".*\n/$1/ ){
       $tap{"${name}c_name"} = $data;
     }
    }
   close $BREW;
  }
 }

unless( $ARGV[0] ){
 open my $FILE,'<',"$ENV{'HOME'}/.BREW_LIST/brew.txt" or die " FILE $!\n";
  my @LIST = <$FILE>;
 close $FILE;

   my( $TIN,$UAA,$AIA,$ACA );
  @BREW = sort grep{ s|.+/(.+)\.rb|$1| }@BREW;
 if( $re->{'MAC'} ){
  for(@CASK){
   last unless m[$MY_BREW/Homebrew/Library/Taps/homebrew/homebrew-cask/Casks/|
                 $MY_BREW/Library/Taps/homebrew/homebrew-cask/]x;
   my( $name ) = m|.+/(.+)\.rb|;
    $ACA .= "$name \\\n";
  }
  @CASK = sort grep{ s|.+/(.+)\.rb|$1| }@CASK;
 }

  my $COU = $IN = 0;
 for(my $i=0;$i<@BREW;$i++){
  $TIN .= "$BREW[$i] \\\n" if $tap{"$BREW[$i]deps"} or $tap{"$BREW[$i]deps_b"} and not $tap{"$BREW[$i]$OS_Version2"};
  $UAA .= "$BREW[$i] \\\n" if $tap{"$BREW[$i]uses"};
  $AIA .= "$BREW[$i] \\\n";
   for(;$COU<@LIST;$COU++){
    my( $ls1,$ls2,$ls3 ) = split '\t',$LIST[$COU];
     $tap{"$BREW[$i]ver"} = $tap{"$BREW[$i]f_version"}, last if $BREW[$i] lt $ls1;
      if( $BREW[$i] eq $ls1 ){
       $tap{"$BREW[$i]ver"} = Version_1( $ls2,$tap{"$BREW[$i]f_version"} ) ? $ls2 : $tap{"$BREW[$i]f_version"};
       $tap{"$BREW[$i]ver"} = $tap{"$BREW[$i]ver"}.$tap{"$BREW[$i]revision"} if $tap{"$BREW[$i]revision"};
       $COU++; last;
      }
   }
   if( $re->{'MAC'} ){
     for(;$IN<@CASK;$IN++){
      last if $BREW[$i] lt $CASK[$IN];
       if($BREW[$i] eq $CASK[$IN]){
        $tap{"$CASK[$IN]so_name"} = 1;
        $IN++; last;
       }
     }
   }
 } my( $COM,$DEP,@TRE,%HAU );
  for my $br(glob "$re->{'CEL'}/*"){
   $br =~ s|.+/(.+)|$1|;
   if( $tap{"${br}deps"} ){ push @TRE,$br;
    $HAU{$_}++ for split '\t',$tap{"${br}deps"};
     $DEP .= "$br \\\n";
   } $COM .= "$br \\\n";
  }
 if( $re->{'MAC'} ){
  for my $ca(@CASK){
   $TIN .= "$ca \\\n" if $tap{"${ca}formula"} or $tap{"${ca}d_cask"};
   $UAA .= "$ca \\\n" if $tap{"${ca}u_cask"} or  $tap{"${ca}u_form"};
  }
   my $glo = -d '/usr/local/Caskroom' ? '/usr/local/Caskroom' : "$MY_BREW/Caskroom";
  for my $gs(glob "$glo/*"){ my $ls;
   $gs =~ s|.+/(.+)|$1|;
   if( $tap{"${gs}d_cask"} ){
    $HAU{$_}++ for split '\t',$tap{"${gs}d_cask"};
     $ls = push @TRE,$gs;
      $DEP .= "$gs \\\n";
   }
   if( $tap{"${gs}formula"} ){
    $HAU{$_}++ for split '\t',$tap{"${gs}formula"};
     push @TRE,$gs unless $ls;
      $DEP .= "$gs \\\n";
   }
  }
 } my( $UCC,$TRE );
  $TRE .= $HAU{$_} ? '' : "$_ \\\n" for @TRE;
   $UCC .= "$_ \\\n" for sort keys %HAU;
    $TRE = ( $TRE and $TRE =~ s/(.+)\\\n$/{-d,-dd,-de}'[Delete item]:Delete:( \\\n$1 )' \\\n/s ) ? $TRE : '';
     $UCC = ( $UCC and $UCC =~ s/(.+)\\\n$/{-u,-ul}'[Uses list]:uses:( \\\n$1 )' \\\n/s )        ? $UCC : '';
      $AIA = ( $AIA and $AIA =~ s/(.+)\\\n$/'-ai[Formula Analytics]:Formula:( \\\n$1 )' \\\n/s ) ? $AIA : '';
       $ACA = ( $ACA and $ACA =~ s/(.+)\\\n$/'-ac[Cask Analytics]:Casks:( \\\n$1 )' \\\n/s )     ? $ACA : '';
  $TIN = ( $TIN and $TIN =~ s/(.+)\\\n$/{-t,-tt,-in}'[Depends item]:Depends:( \\\n$1 )' \\\n/s ) ? $TIN : '';
   $FON = ( $FON and $FON =~ s/(.+)\\\n$/'-p[Fonts list]:Fonts:( \\\n$1 )' \\\n/s )              ? $FON : '';
    $COM = ( $COM and $COM =~ s/(.+)\\\n$/{-co,-is}'[Library list]:Library:( \\\n$1 )' \\\n/s )  ? $COM : '';
     $UAA = ( $UAA and $UAA =~ s/(.+)\\\n$/'-ua[All uses list]:USES:( \\\n$1 )' \\\n/s )         ? $UAA : '';
      $DEP = ( $DEP and $DEP =~ s/(.+)\\\n$/'-ud[Depends list]:DEPS:( \\\n$1 )' \\\n/s )         ? $DEP : '';
  my $TOP = "#compdef bl\n_bl(){\n_arguments '*::' \\\n$TRE$TIN$UAA$UCC$COM$DEP$AIA$ACA$FON}";
   no warnings 'closed';
  open my $dir,'>',"$re->{'COM'}/_bl";
   print $dir $TOP;
  close $dir;
}
untie %tap;
